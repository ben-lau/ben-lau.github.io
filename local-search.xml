<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何用一个定时器做延时队列</title>
    <link href="/%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8%E5%81%9A%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/"/>
    <url>/%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8%E5%81%9A%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="如何用一个定时器做延时队列"><a href="#如何用一个定时器做延时队列" class="headerlink" title="如何用一个定时器做延时队列"></a>如何用一个定时器做延时队列</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>起因是团队内小伙伴遇到了一个有意思的题，大概内容是这样：如何实现类似 Message 组件（全局通知提示，几秒钟自动消失的那种）的调度功能。这个题这样子看很简单，大概是这样</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> showMessage = <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> message = Message.show(msg);    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      message.close();      resolve();    &#125;, delay);  &#125;);</code></pre><p>大致意思就是如此，每次显示就开启定时器并在定时器结束后关闭，虽然没很完整具体实现，但是很容易理解这题目的意思</p><p>后来就被问到：<strong>能否用一个定时器实现</strong>？</p><p>小伙伴对此比较<strong>懵</strong>，所以我在这里也试着实现一下</p><h2 id="为什么感兴趣"><a href="#为什么感兴趣" class="headerlink" title="为什么感兴趣"></a>为什么感兴趣</h2><p>实际上这种场景在业务中也是比较多，除了上面说的 Message 组件，还有类似以下的场景：</p><ul><li>用户下单后超过 30 分钟不支付则自动取消订单并归还库存</li><li>会议室被预定了会在开始前 15 分钟通知用户<br>…</li></ul><p>这些<strong>延迟时间已知，但是随时可能被创建</strong>的场景，延时队列就是其中一种方案，说是队列但是并不遵从先进先出，应该是按时间进行的结构。而中心化调度可以把过程控制在一个地方，也较好维护（其实真实业务直接创定时器就可以了，主要是小伙伴搞不定）</p><h2 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h2><p>首先要知道这题目的是看是否能中心化调度，而且每个任务都是延迟的，而且还有可能<strong>后加入</strong>的任务延迟时间比已有的定时器更早达到，这种情况就需要不断地调整定时器。</p><p>而我们知道定时器 api：<code>setTimeout</code>是无法修改时间的，只能手动清除；那么第二个想到的就是类似<code>requestAnimationFrame</code>的方案，在每次回调中检查时间并查询任务队列中的延时任务是否已经到达然后执行，但是这种方案其实性能更差也更多的无意义判断和调用</p><p>后面我就只能往<strong>同时只存在一个</strong>定时器的实现情况，也就是说动态化定时器</p><p>那既然有了想法就开始想思路，其实很简单</p><ol><li>创建单例定时器，并且维护一个任务队列</li><li>插入任务并且开始启动定时器</li><li>在等待时如果插入了别的任务，则取消定时器，并计算<strong>相对时间</strong>重新开启</li><li>定时器通知中心调度并取出达到的任务，并执行后出列</li><li>重复上述步骤直到队列被清空</li></ol><p>有了思路之后，开始看看是否有问题，首先是不断的重启定时器感觉好像有点浪费性能，然后还有小伙伴会觉得需要做个排序（甚至默写了一个插排），其实这里用相对时间做缓存记录即可，但是要注意一个点就是<strong>相对时间</strong>：</p><p>假设我们有三个任务分别创建，任务一延时 2 秒，任务二延时 2 秒在 1 秒后插入，任务三延时 1 秒在 1.5 秒后插入，如下图</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/delay-queue-example.png" alt="时间轴示例"></p><p>可以看到，在任务一时我们创建了一个 2 秒的定时器，在 1 秒后，插入了任务二，其实他会在任务一之后才完成，那其实我们完全可以不重启定时器，因为在任务一完成后我们再计算即可。但是要注意的是，任务二也是 2 秒任务，但是我们期望是在时间轴的<strong>第 3 秒</strong>执行，如果我们直接存起来，那就会变成第 4 秒才执行了（2 秒后再等 2 秒执行任务二），所以其实我们可以把任务二补足时间，以当前定时器的启动时期间为基准，因为如果任务较多的话，基准多就容易出问题。</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/delay-queue-patch.png" alt="时间轴补丁示例"></p><p>然后看任务三，任务三是后面插入的任务但是他会比任务一更早完成，那这个时候就无法利用已有的任务一定时器，这种情况才必要重启定时器，并且要修改任务 1 的相对基准时间为 1.5 秒后，如图所示：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/delay-queue-patch-2.png" alt="时间轴补丁示例2"></p><p>到这里为止其实思路都完整了，我们可以画成一个流程图更好帮助我们编码</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/delay-queue-flow.png" alt="编码流程图"></p><h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><p>首先我们可以先做好拆分，因为延时任务队列其实跟定时器无关的，那定时器我们可以稍微封装一下，因为需要记录创建时间和一个获取已经过了的时间：</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> </span>&#123;  <span class="hljs-comment">// 是否启动</span>  active = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 本次延时</span>  #delay = 0;  <span class="hljs-comment">// 创建时间</span>  #timestamp = 0;  <span class="hljs-comment">// 定时器实例</span>  #id = null;  <span class="hljs-comment">// 任务内容</span>  #task = null;  <span class="hljs-comment">// 获取已过去的时间</span>  <span class="hljs-keyword">get</span> <span class="hljs-title">passedTime</span>() &#123;    return this.active ? Date.now() - this.#timestamp : 0;  &#125;  <span class="hljs-comment">// 获取剩余时间</span>  <span class="hljs-keyword">get</span> <span class="hljs-title">restTime</span>() &#123;    return this.active ? this.#delay - this.passedTime : 0;  &#125;  set(task, delay) &#123;    if (this.#id) &#123;      <span class="hljs-built_in">this</span>.stop();    &#125;    this.#timestamp = Date.now();    this.#delay = delay;    this.#task = task;    <span class="hljs-built_in">this</span>.active = <span class="hljs-literal">true</span>;    this.#id = setTimeout(() =&gt; &#123;      this.#task.call(null);      <span class="hljs-built_in">this</span>.active = <span class="hljs-literal">false</span>;    &#125;, this.#delay);  &#125;  stop() &#123;    clearTimeout(this.#id);    <span class="hljs-built_in">this</span>.active = <span class="hljs-literal">false</span>;    this.#delay = 0;    this.#id = null;  &#125;&#125;</code></pre><p>ok，到此我们有个自己的定时器，定时器在启动时会清除存在的定时器，这样子就能保证我们同时只有一个定时器在运行</p><p>截下来我们要开始写延时队列，首先得有定时器实例，也要有一个集合存储，这里我们用 <code>Set</code>，因为其实我们不需要获取某个下标的内容，更需要承担一个增删压力</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayQueue</span> </span>&#123;  #timer = new Timer();  #queue = new Set();&#125;</code></pre><p>这个队列的核心 api 就是添加任务了，顺便可以定一个简单的任务实例结构</p><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Task &#123;  delay: <span class="hljs-built_in">number</span>;  run(): unknown;&#125;</code></pre><p>然后可以添加任务，添加任务时记得要获取定时器的已过时间并抹平，并且如果新增的任务延时不超过现在剩余时间，那就是说我们当前定时器还可以用，就不需要重新开启</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayQueue</span> </span>&#123;  add(run, delay = <span class="hljs-number">0</span>) &#123;    this.#queue.add(&#123;      run,      delay: delay + this.#timer.passedTime,    &#125;);    if (this.#timer.restTime &gt; delay || !this.active) &#123;      this.#setSchedule();    &#125;  &#125;&#125;</code></pre><p>开启定时任务的方法，我们需要绑定回调的同时，需要有一个抹平当前时间的 api，并且能返回当前任务队列中最近的任务延时</p><p>而为什么需要抹平，上面也已经说过了，当一个回调完成后，当前队列中任务还是以上一个为基准的，那我们需要把基准时间修改，并同时作用于所有集合内的任务</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayQueue</span> </span>&#123;  #refreshRestTime() &#123;    <span class="hljs-keyword">let</span> minDelay = <span class="hljs-literal">null</span>;    const passedTime = this.#timer.passedTime;    this.#queue.forEach(item =&gt; &#123;      item.delay -= passedTime;      <span class="hljs-keyword">if</span> (minDelay === <span class="hljs-literal">null</span> || minDelay &gt; item.delay) &#123;        minDelay = item.delay;      &#125;    &#125;);    <span class="hljs-keyword">return</span> minDelay;  &#125;  #setSchedule() &#123;    const delay = this.#refreshRestTime();    <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;      this.#timer.set(() =&gt; &#123;        this.#resolveTask();      &#125;, delay);    &#125;);  &#125;&#125;</code></pre><p>ok，到这里回调就很简单了，无非就是找到并且调用，然后出列，最后再重新启动即可</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayQueue</span> </span>&#123;  #getClosestTasks() &#123;    <span class="hljs-keyword">let</span> results = [];    <span class="hljs-keyword">let</span> minDelay = <span class="hljs-literal">null</span>;    this.#queue.forEach(item =&gt; &#123;      <span class="hljs-keyword">if</span> (minDelay === <span class="hljs-literal">null</span> || minDelay &gt; item.delay) &#123;        minDelay = item.delay;        results = [item];      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minDelay === item.delay) &#123;        results.push(item);      &#125;    &#125;);    <span class="hljs-keyword">return</span> [results, minDelay];  &#125;  #resolveTask() &#123;    const [results] = this.#getClosestTasks();    results.forEach(<span class="hljs-function"><span class="hljs-params">task</span> =&gt;</span> &#123;      this.#queue.delete(task);      task.run();    &#125;);    if (this.#queue.size) &#123;      this.#setSchedule();    &#125;  &#125;&#125;</code></pre><p>最后写个简单的测试用例，包含先进后跑，后进先跑，先进先跑，后进后跑的场景</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> $$log = <span class="hljs-function">(<span class="hljs-params">...msg</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toTimeString(), ...msg);<span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> DelayQueue();<span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();$$log(<span class="hljs-number">1</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  queue.add(<span class="hljs-function">() =&gt;</span> $$log(<span class="hljs-string">&#x27;1000ms&#x27;</span>, <span class="hljs-built_in">Date</span>.now() - start), <span class="hljs-number">1000</span>);&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  queue.add(<span class="hljs-function">() =&gt;</span> $$log(<span class="hljs-string">&#x27;1500ms&#x27;</span>, <span class="hljs-built_in">Date</span>.now() - start), <span class="hljs-number">1000</span>);&#125;, <span class="hljs-number">500</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  queue.add(<span class="hljs-function">() =&gt;</span> $$log(<span class="hljs-string">&#x27;1500ms&#x27;</span>, <span class="hljs-built_in">Date</span>.now() - start), <span class="hljs-number">500</span>);&#125;, <span class="hljs-number">1000</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  queue.add(<span class="hljs-function">() =&gt;</span> $$log(<span class="hljs-string">&#x27;800ms&#x27;</span>, <span class="hljs-built_in">Date</span>.now() - start), <span class="hljs-number">500</span>);&#125;, <span class="hljs-number">300</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  queue.add(<span class="hljs-function">() =&gt;</span> $$log(<span class="hljs-string">&#x27;3100ms&#x27;</span>, <span class="hljs-built_in">Date</span>.now() - start), <span class="hljs-number">100</span>);&#125;, <span class="hljs-number">3000</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  queue.add(<span class="hljs-function">() =&gt;</span> $$log(<span class="hljs-string">&#x27;2600ms&#x27;</span>, <span class="hljs-built_in">Date</span>.now() - start), <span class="hljs-number">2500</span>);&#125;, <span class="hljs-number">100</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  queue.add(<span class="hljs-function">() =&gt;</span> $$log(<span class="hljs-string">&#x27;1000ms&#x27;</span>, <span class="hljs-built_in">Date</span>.now() - start), <span class="hljs-number">500</span>);&#125;, <span class="hljs-number">500</span>);</code></pre><p>最后附上 <strong><a href="https://github.com/ben-lau/blog/blob/master/assets/script/DelayQueue.js">完整代码</a></strong></p><p>总结一下就是，其实写多个 setTimeout 会更简单，只需要存储创建任务对象即可，但是多学习总归没有错的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node是如何同步写入文件的</title>
    <link href="/node%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E7%9A%84/"/>
    <url>/node%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="node-是如何同步写入文件的"><a href="#node-是如何同步写入文件的" class="headerlink" title="node 是如何同步写入文件的"></a>node 是如何同步写入文件的</h1><p>最近在知乎上被邀请了一个问题，觉得比较有趣就试着回答了一下。</p><p>众所周知，nodejs 的 io 是非阻塞模型，但是还提供了同步接口，这一点确实有趣，那到底是怎么实现这些文件写入的呢？</p><p><strong>以下的源码都是基于 node 16.17.0</strong></p><h2 id="node-部分"><a href="#node-部分" class="headerlink" title="node 部分"></a>node 部分</h2><p>我们知道 fs 中写入文件的 api: <code>writeFile</code>和<code>writeFileSync</code>，那他们到底做了什么呢，我们可以先看源码：<a href="https://github.com/nodejs/node/blob/main/lib/fs.js">都在这</a></p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Asynchronously writes data to the file.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string | Buffer | URL | number&#125;</span> <span class="hljs-variable">path</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string | Buffer | TypedArray | DataView | object&#125;</span> <span class="hljs-variable">data</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;&#123;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   encoding?: string | null;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   mode?: number;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   flag?: string;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   signal?: AbortSignal;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   &#125;</span> </span>| string&#125; [options]</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;(err?: Error) =&gt; any&#125;</span> <span class="hljs-variable">callback</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeFile</span>(<span class="hljs-params">path, data, options, callback</span>) </span>&#123;  callback = maybeCallback(callback || options);  options = getOptions(options, &#123; <span class="hljs-attr">encoding</span>: <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-attr">mode</span>: <span class="hljs-number">0o666</span>, <span class="hljs-attr">flag</span>: <span class="hljs-string">&#x27;w&#x27;</span> &#125;);  <span class="hljs-keyword">const</span> flag = options.flag || <span class="hljs-string">&#x27;w&#x27;</span>;  <span class="hljs-keyword">if</span> (!isArrayBufferView(data)) &#123;    validateStringAfterArrayBufferView(data, <span class="hljs-string">&#x27;data&#x27;</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;      showStringCoercionDeprecation();    &#125;    data = Buffer.from(<span class="hljs-built_in">String</span>(data), options.encoding || <span class="hljs-string">&#x27;utf8&#x27;</span>);  &#125;  <span class="hljs-keyword">if</span> (isFd(path)) &#123;    <span class="hljs-keyword">const</span> isUserFd = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">const</span> signal = options.signal;    writeAll(path, isUserFd, data, <span class="hljs-number">0</span>, data.byteLength, signal, callback);    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">if</span> (checkAborted(options.signal, callback)) <span class="hljs-keyword">return</span>;  fs.open(path, flag, options.mode, <span class="hljs-function">(<span class="hljs-params">openErr, fd</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (openErr) &#123;      callback(openErr);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">const</span> isUserFd = <span class="hljs-literal">false</span>;      <span class="hljs-keyword">const</span> signal = options.signal;      writeAll(fd, isUserFd, data, <span class="hljs-number">0</span>, data.byteLength, signal, callback);    &#125;  &#125;);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Synchronously writes data to the file.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string | Buffer | URL | number&#125;</span> <span class="hljs-variable">path</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string | Buffer | TypedArray | DataView | object&#125;</span> <span class="hljs-variable">data</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;&#123;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   encoding?: string | null;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   mode?: number;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   flag?: string;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   &#125;</span> </span>| string&#125; [options]</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeFileSync</span>(<span class="hljs-params">path, data, options</span>) </span>&#123;  options = getOptions(options, &#123; <span class="hljs-attr">encoding</span>: <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-attr">mode</span>: <span class="hljs-number">0o666</span>, <span class="hljs-attr">flag</span>: <span class="hljs-string">&#x27;w&#x27;</span> &#125;);  <span class="hljs-keyword">if</span> (!isArrayBufferView(data)) &#123;    validateStringAfterArrayBufferView(data, <span class="hljs-string">&#x27;data&#x27;</span>);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;      showStringCoercionDeprecation();    &#125;    data = Buffer.from(<span class="hljs-built_in">String</span>(data), options.encoding || <span class="hljs-string">&#x27;utf8&#x27;</span>);  &#125;  <span class="hljs-keyword">const</span> flag = options.flag || <span class="hljs-string">&#x27;w&#x27;</span>;  <span class="hljs-keyword">const</span> isUserFd = isFd(path); <span class="hljs-comment">// File descriptor ownership</span>  <span class="hljs-keyword">const</span> fd = isUserFd ? path : fs.openSync(path, flag, options.mode);  <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> length = data.byteLength;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">while</span> (length &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">const</span> written = fs.writeSync(fd, data, offset, length);      offset += written;      length -= written;    &#125;  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">if</span> (!isUserFd) fs.closeSync(fd);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeAll</span>(<span class="hljs-params">fd, isUserFd, buffer, offset, length, signal, callback</span>) </span>&#123;  <span class="hljs-keyword">if</span> (signal?.aborted) &#123;    <span class="hljs-keyword">const</span> abortError = <span class="hljs-keyword">new</span> AbortError(<span class="hljs-literal">undefined</span>, &#123; <span class="hljs-attr">cause</span>: signal?.reason &#125;);    <span class="hljs-keyword">if</span> (isUserFd) &#123;      callback(abortError);    &#125; <span class="hljs-keyword">else</span> &#123;      fs.close(fd, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;        callback(aggregateTwoErrors(err, abortError));      &#125;);    &#125;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-comment">// write(fd, buffer, offset, length, position, callback)</span>  fs.write(fd, buffer, offset, length, <span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">writeErr, written</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (writeErr) &#123;      <span class="hljs-keyword">if</span> (isUserFd) &#123;        callback(writeErr);      &#125; <span class="hljs-keyword">else</span> &#123;        fs.close(fd, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;          callback(aggregateTwoErrors(err, writeErr));        &#125;);      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (written === length) &#123;      <span class="hljs-keyword">if</span> (isUserFd) &#123;        callback(<span class="hljs-literal">null</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        fs.close(fd, callback);      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      offset += written;      length -= written;      writeAll(fd, isUserFd, buffer, offset, length, signal, callback);    &#125;  &#125;);&#125;</code></pre><p>可以看到 <code>writFileSync</code> 中实际上是调用 <code>writeSync</code>，而 <code>writeFile</code> 内部调用了异步 <code>open</code> 里面用了一个递归函数 <code>writeAll</code>，最终是调用 <code>write</code> 函数。</p><p>然后再看看 <a href="https://github.com/nodejs/node/blob/main/lib/fs.js#L822">write</a> 和 <a href="https://github.com/nodejs/node/blob/main/lib/fs.js#L897">writeSync</a></p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Writes `buffer` to the specified `fd` (file descriptor).</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">fd</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Buffer | TypedArray | DataView | string | object&#125;</span> <span class="hljs-variable">buffer</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number | object&#125;</span> </span>[offsetOrOptions]</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>[length]</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number | null&#125;</span> </span>[position]</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;(</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   err?: Error,</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   bytesWritten?: number;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   buffer?: Buffer | TypedArray | DataView</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   ) =&gt; any&#125;</span> <span class="hljs-variable">callback</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params">fd, buffer, offsetOrOptions, length, position, callback</span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">err, written</span>) </span>&#123;    <span class="hljs-comment">// Retain a reference to buffer so that it can&#x27;t be GC&#x27;ed too soon.</span>    callback(err, written || <span class="hljs-number">0</span>, buffer);  &#125;  fd = getValidatedFd(fd);  <span class="hljs-keyword">let</span> offset = offsetOrOptions;  <span class="hljs-keyword">if</span> (isArrayBufferView(buffer)) &#123;    callback = maybeCallback(callback || position || length || offset);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> offset === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;      (&#123;        offset = <span class="hljs-number">0</span>,        length = buffer.byteLength - offset,        position = <span class="hljs-literal">null</span>,      &#125; = offsetOrOptions ?? kEmptyObject);    &#125;    <span class="hljs-keyword">if</span> (offset == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> offset === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;      offset = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      validateInteger(offset, <span class="hljs-string">&#x27;offset&#x27;</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> length !== <span class="hljs-string">&#x27;number&#x27;</span>) length = buffer.byteLength - offset;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> position !== <span class="hljs-string">&#x27;number&#x27;</span>) position = <span class="hljs-literal">null</span>;    validateOffsetLengthWrite(offset, length, buffer.byteLength);    <span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> FSReqCallback();    req.oncomplete = wrapper;    <span class="hljs-keyword">return</span> binding.writeBuffer(fd, buffer, offset, length, position, req);  &#125;  validateStringAfterArrayBufferView(buffer, <span class="hljs-string">&#x27;buffer&#x27;</span>);  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> buffer !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;    showStringCoercionDeprecation();  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> position !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> offset === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;      position = offset;      offset = <span class="hljs-literal">null</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      position = length;    &#125;    length = <span class="hljs-string">&#x27;utf8&#x27;</span>;  &#125;  <span class="hljs-keyword">const</span> str = <span class="hljs-built_in">String</span>(buffer);  validateEncoding(str, length);  callback = maybeCallback(position);  <span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> FSReqCallback();  req.oncomplete = wrapper;  <span class="hljs-keyword">return</span> binding.writeString(fd, str, offset, length, req);&#125;ObjectDefineProperty(write, kCustomPromisifyArgsSymbol, &#123;  __proto__: <span class="hljs-literal">null</span>,  value: [<span class="hljs-string">&#x27;bytesWritten&#x27;</span>, <span class="hljs-string">&#x27;buffer&#x27;</span>],  enumerable: <span class="hljs-literal">false</span>,&#125;);<span class="hljs-comment">/**</span><span class="hljs-comment"> * Synchronously writes `buffer` to the</span><span class="hljs-comment"> * specified `fd` (file descriptor).</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">fd</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Buffer | TypedArray | DataView | string&#125;</span> <span class="hljs-variable">buffer</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;&#123;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   offset?: number;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   length?: number;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   position?: number | null;</span></span></span><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   &#125;</span></span>&#125; [offsetOrOptions]</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;number&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeSync</span>(<span class="hljs-params">fd, buffer, offsetOrOptions, length, position</span>) </span>&#123;  fd = getValidatedFd(fd);  <span class="hljs-keyword">const</span> ctx = &#123;&#125;;  <span class="hljs-keyword">let</span> result;  <span class="hljs-keyword">let</span> offset = offsetOrOptions;  <span class="hljs-keyword">if</span> (isArrayBufferView(buffer)) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> offset === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;      (&#123;        offset = <span class="hljs-number">0</span>,        length = buffer.byteLength - offset,        position = <span class="hljs-literal">null</span>,      &#125; = offsetOrOptions ?? kEmptyObject);    &#125;    <span class="hljs-keyword">if</span> (position === <span class="hljs-literal">undefined</span>) position = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (offset == <span class="hljs-literal">null</span>) &#123;      offset = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      validateInteger(offset, <span class="hljs-string">&#x27;offset&#x27;</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> length !== <span class="hljs-string">&#x27;number&#x27;</span>) length = buffer.byteLength - offset;    validateOffsetLengthWrite(offset, length, buffer.byteLength);    result = binding.writeBuffer(      fd,      buffer,      offset,      length,      position,      <span class="hljs-literal">undefined</span>,      ctx    );  &#125; <span class="hljs-keyword">else</span> &#123;    validatePrimitiveStringAfterArrayBufferView(buffer, <span class="hljs-string">&#x27;buffer&#x27;</span>);    validateEncoding(buffer, length);    <span class="hljs-keyword">if</span> (offset === <span class="hljs-literal">undefined</span>) offset = <span class="hljs-literal">null</span>;    result = binding.writeString(fd, buffer, offset, length, <span class="hljs-literal">undefined</span>, ctx);  &#125;  handleErrorFromBinding(ctx);  <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>其实最终都是调用 <code>binding.writeBuffer</code> 和 <code>binding.writeString</code>，区别在于参数，在异步 <code>wirte</code> 中实际上多了一个请求回调对象，而这个请求对象是由 c++模块导出，<a href="https://github.com/nodejs/node/blob/main/src/node_file.cc#L606">这个可以先了解一下</a></p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> FSReqCallback();req.oncomplete = wrapper;</code></pre><p>以同步调用的 <code>writeSync</code> 为例子，<code>writeBuffer</code> 和 <code>writeString</code> 的第六、第五个参数是 undefined；而 <code>write</code> 中，<code>writeBuffer</code> 就把 <code>req</code> 传进了第六个参数中，这里是一个细节</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/node-io-details.jpeg" alt="一个细节"></p><p>到这里为止，都是 js 范畴</p><p>然后也应该清楚 <code>writeFile</code>、<code>writeFileSync</code> 内部调用 <code>write</code>、<code>writeFile</code>，而他们最终其实调用了 <code>binding.writeBuffer</code> 或者 <code>binding.writeString</code>。</p><p>而<code>binding</code> 是 js 和 c++中间的桥梁，用于给 js 上层提供 api，所以下面就开始 c++模块部分了。</p><h2 id="C-部分"><a href="#C-部分" class="headerlink" title="C++ 部分"></a>C++ 部分</h2><p>在 <a href="https://github.com/nodejs/node/blob/main/src/node_file.cc#L2462">node_file.cc</a> 中定义对外的 api 命名</p><pre><code class="hljs cpp">SetMethod(context, target, <span class="hljs-string">&quot;writeBuffer&quot;</span>, WriteBuffer);SetMethod(context, target, <span class="hljs-string">&quot;writeString&quot;</span>, WriteString);</code></pre><p>在 <a href="https://github.com/nodejs/node/blob/main/src/node_file.cc#L1802">writeBuffer</a> 中，判断了第 6 个参数请求回调对象是否存在决定是否异步</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteBuffer</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;  Environment* env = Environment::GetCurrent(args);  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> argc = args.Length();  CHECK_GE(argc, <span class="hljs-number">4</span>);  CHECK(args[<span class="hljs-number">0</span>]-&gt;IsInt32());  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd = args[<span class="hljs-number">0</span>].As&lt;Int32&gt;()-&gt;Value();  CHECK(Buffer::HasInstance(args[<span class="hljs-number">1</span>]));  Local&lt;Object&gt; buffer_obj = args[<span class="hljs-number">1</span>].As&lt;Object&gt;();  <span class="hljs-keyword">char</span>* buffer_data = Buffer::Data(buffer_obj);  <span class="hljs-keyword">size_t</span> buffer_length = Buffer::Length(buffer_obj);  CHECK(IsSafeJsInt(args[<span class="hljs-number">2</span>]));  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> off_64 = args[<span class="hljs-number">2</span>].As&lt;Integer&gt;()-&gt;Value();  CHECK_GE(off_64, <span class="hljs-number">0</span>);  CHECK_LE(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt;(off_64), buffer_length);  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> off = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(off_64);  CHECK(args[<span class="hljs-number">3</span>]-&gt;IsInt32());  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> len = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(args[<span class="hljs-number">3</span>].As&lt;Int32&gt;()-&gt;Value());  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));  CHECK_LE(len, buffer_length);  CHECK_GE(off + len, off);  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> pos = GetOffset(args[<span class="hljs-number">4</span>]);  <span class="hljs-keyword">char</span>* buf = buffer_data + off;  <span class="hljs-keyword">uv_buf_t</span> uvbuf = uv_buf_init(buf, len);  FSReqBase* req_wrap_async = GetReqWrap(args, <span class="hljs-number">5</span>);  <span class="hljs-keyword">if</span> (req_wrap_async != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// write(fd, buffer, off, len, pos, req)</span>    AsyncCall(env, req_wrap_async, args, <span class="hljs-string">&quot;write&quot;</span>, UTF8, AfterInteger,              uv_fs_write, fd, &amp;uvbuf, <span class="hljs-number">1</span>, pos);  &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// write(fd, buffer, off, len, pos, undefined, ctx)</span>    CHECK_EQ(argc, <span class="hljs-number">7</span>);    FSReqWrapSync req_wrap_sync;    FS_SYNC_TRACE_BEGIN(write);    <span class="hljs-keyword">int</span> bytesWritten = SyncCall(env, args[<span class="hljs-number">6</span>], &amp;req_wrap_sync, <span class="hljs-string">&quot;write&quot;</span>,                                uv_fs_write, fd, &amp;uvbuf, <span class="hljs-number">1</span>, pos);    FS_SYNC_TRACE_END(write, <span class="hljs-string">&quot;bytesWritten&quot;</span>, bytesWritten);    args.GetReturnValue().Set(bytesWritten);  &#125;&#125;</code></pre><p><a href="https://github.com/nodejs/node/blob/main/src/node_file.cc#L1902">writeString</a> 则判断了第五个参数请求回调对象是否存在，而确定是否用异步</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;  Environment* env = Environment::GetCurrent(args);  Isolate* isolate = env-&gt;isolate();  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> argc = args.Length();  CHECK_GE(argc, <span class="hljs-number">4</span>);  CHECK(args[<span class="hljs-number">0</span>]-&gt;IsInt32());  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fd = args[<span class="hljs-number">0</span>].As&lt;Int32&gt;()-&gt;Value();  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> pos = GetOffset(args[<span class="hljs-number">2</span>]);  <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> enc = ParseEncoding(isolate, args[<span class="hljs-number">3</span>], UTF8);  Local&lt;Value&gt; value = args[<span class="hljs-number">1</span>];  <span class="hljs-keyword">char</span>* buf = <span class="hljs-literal">nullptr</span>;  <span class="hljs-keyword">size_t</span> len;  FSReqBase* req_wrap_async = GetReqWrap(args, <span class="hljs-number">4</span>);  <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> is_async = req_wrap_async != <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// Avoid copying the string when it is externalized but only when:</span>  <span class="hljs-comment">// 1. The target encoding is compatible with the string&#x27;s encoding, and</span>  <span class="hljs-comment">// 2. The write is synchronous, otherwise the string might get neutered</span>  <span class="hljs-comment">//    while the request is in flight, and</span>  <span class="hljs-comment">// 3. For UCS2, when the host system is little-endian.  Big-endian systems</span>  <span class="hljs-comment">//    need to call StringBytes::Write() to ensure proper byte swapping.</span>  <span class="hljs-comment">// The const_casts are conceptually sound: memory is read but not written.</span>  <span class="hljs-keyword">if</span> (!is_async &amp;&amp; value-&gt;IsString()) &#123;    <span class="hljs-keyword">auto</span> <span class="hljs-built_in">string</span> = value.As&lt;String&gt;();    <span class="hljs-keyword">if</span> ((enc == ASCII || enc == LATIN1) &amp;&amp; <span class="hljs-built_in">string</span>-&gt;IsExternalOneByte()) &#123;      <span class="hljs-keyword">auto</span> ext = <span class="hljs-built_in">string</span>-&gt;GetExternalOneByteStringResource();      buf = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(ext-&gt;data());      len = ext-&gt;length();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enc == UCS2 &amp;&amp; IsLittleEndian() &amp;&amp; <span class="hljs-built_in">string</span>-&gt;IsExternalTwoByte()) &#123;      <span class="hljs-keyword">auto</span> ext = <span class="hljs-built_in">string</span>-&gt;GetExternalStringResource();      buf = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">uint16_t</span>*&gt;(ext-&gt;data()));      len = ext-&gt;length() * <span class="hljs-keyword">sizeof</span>(*ext-&gt;data());    &#125;  &#125;  <span class="hljs-keyword">if</span> (is_async) &#123;  <span class="hljs-comment">// write(fd, string, pos, enc, req)</span>    CHECK_NOT_NULL(req_wrap_async);    <span class="hljs-keyword">if</span> (!StringBytes::StorageSize(isolate, value, enc).To(&amp;len)) <span class="hljs-keyword">return</span>;    FSReqBase::FSReqBuffer&amp; stack_buffer =        req_wrap_async-&gt;Init(<span class="hljs-string">&quot;write&quot;</span>, len, enc);    <span class="hljs-comment">// StorageSize may return too large a char, so correct the actual length</span>    <span class="hljs-comment">// by the write size</span>    len = StringBytes::Write(isolate, *stack_buffer, len, args[<span class="hljs-number">1</span>], enc);    stack_buffer.SetLengthAndZeroTerminate(len);    <span class="hljs-keyword">uv_buf_t</span> uvbuf = uv_buf_init(*stack_buffer, len);    <span class="hljs-keyword">int</span> err = req_wrap_async-&gt;Dispatch(uv_fs_write,                                       fd,                                       &amp;uvbuf,                                       <span class="hljs-number">1</span>,                                       pos,                                       AfterInteger);    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">uv_fs_t</span>* uv_req = req_wrap_async-&gt;req();      uv_req-&gt;result = err;      uv_req-&gt;path = <span class="hljs-literal">nullptr</span>;      AfterInteger(uv_req);  <span class="hljs-comment">// after may delete req_wrap_async if there is</span>                             <span class="hljs-comment">// an error</span>    &#125; <span class="hljs-keyword">else</span> &#123;      req_wrap_async-&gt;SetReturnValue(args);    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// write(fd, string, pos, enc, undefined, ctx)</span>    CHECK_EQ(argc, <span class="hljs-number">6</span>);    FSReqWrapSync req_wrap_sync;    FSReqBase::FSReqBuffer stack_buffer;    <span class="hljs-keyword">if</span> (buf == <span class="hljs-literal">nullptr</span>) &#123;      <span class="hljs-keyword">if</span> (!StringBytes::StorageSize(isolate, value, enc).To(&amp;len))        <span class="hljs-keyword">return</span>;      stack_buffer.AllocateSufficientStorage(len + <span class="hljs-number">1</span>);      <span class="hljs-comment">// StorageSize may return too large a char, so correct the actual length</span>      <span class="hljs-comment">// by the write size</span>      len = StringBytes::Write(isolate, *stack_buffer,                               len, args[<span class="hljs-number">1</span>], enc);      stack_buffer.SetLengthAndZeroTerminate(len);      buf = *stack_buffer;    &#125;    <span class="hljs-keyword">uv_buf_t</span> uvbuf = uv_buf_init(buf, len);    FS_SYNC_TRACE_BEGIN(write);    <span class="hljs-keyword">int</span> bytesWritten = SyncCall(env, args[<span class="hljs-number">5</span>], &amp;req_wrap_sync, <span class="hljs-string">&quot;write&quot;</span>,                                uv_fs_write, fd, &amp;uvbuf, <span class="hljs-number">1</span>, pos);    FS_SYNC_TRACE_END(write, <span class="hljs-string">&quot;bytesWritten&quot;</span>, bytesWritten);    args.GetReturnValue().Set(bytesWritten);  &#125;&#125;</code></pre><p>也就是说在 fs 模块中，用回调函数是否存在判断了本次调用是异步还是同步，然后分别调用 AsyncCall 和 SyncCall。后面我们可以看看这两个是什么：</p><p>SyncCall:</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SyncCall</span><span class="hljs-params">(Environment* env, v8::Local&lt;v8::Value&gt; ctx,</span></span><span class="hljs-function"><span class="hljs-params">             FSReqWrapSync* req_wrap, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* syscall,</span></span><span class="hljs-function"><span class="hljs-params">             Func fn, Args... args)</span> </span>&#123;  env-&gt;PrintSyncTrace();  <span class="hljs-keyword">int</span> err = fn(env-&gt;event_loop(), &amp;(req_wrap-&gt;req), args..., <span class="hljs-literal">nullptr</span>);  <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;    v8::Local&lt;v8::Context&gt; context = env-&gt;context();    v8::Local&lt;v8::Object&gt; ctx_obj = ctx.As&lt;v8::Object&gt;();    v8::Isolate* isolate = env-&gt;isolate();    ctx_obj-&gt;Set(context,                 env-&gt;errno_string(),                 v8::Integer::New(isolate, err)).Check();    ctx_obj-&gt;Set(context,                 env-&gt;syscall_string(),                 OneByteString(isolate, syscall)).Check();  &#125;  <span class="hljs-keyword">return</span> err;&#125;</code></pre><p>AsyncCall:</p><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function">FSReqBase* <span class="hljs-title">AsyncDestCall</span><span class="hljs-params">(Environment* env, FSReqBase* req_wrap,</span></span><span class="hljs-function"><span class="hljs-params">                         <span class="hljs-keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args,</span></span><span class="hljs-function"><span class="hljs-params">                         <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* syscall, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* dest,</span></span><span class="hljs-function"><span class="hljs-params">                         <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">enum</span> encoding enc, uv_fs_cb after,</span></span><span class="hljs-function"><span class="hljs-params">                         Func fn, Args... fn_args)</span> </span>&#123;  CHECK_NOT_NULL(req_wrap);  req_wrap-&gt;Init(syscall, dest, len, enc);  <span class="hljs-keyword">int</span> err = req_wrap-&gt;Dispatch(fn, fn_args..., after);  <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">uv_fs_t</span>* uv_req = req_wrap-&gt;req();    uv_req-&gt;result = err;    uv_req-&gt;path = <span class="hljs-literal">nullptr</span>;    after(uv_req);  <span class="hljs-comment">// after may delete req_wrap if there is an error</span>    req_wrap = <span class="hljs-literal">nullptr</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    req_wrap-&gt;SetReturnValue(args);  &#125;  <span class="hljs-keyword">return</span> req_wrap;&#125;<span class="hljs-comment">// Returns nullptr if the operation fails from the start.</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span>... Args&gt;<span class="hljs-function">FSReqBase* <span class="hljs-title">AsyncCall</span><span class="hljs-params">(Environment* env,</span></span><span class="hljs-function"><span class="hljs-params">                     FSReqBase* req_wrap,</span></span><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">const</span> v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args,</span></span><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* syscall, <span class="hljs-keyword">enum</span> encoding enc,</span></span><span class="hljs-function"><span class="hljs-params">                     uv_fs_cb after, Func fn, Args... fn_args)</span> </span>&#123;  <span class="hljs-keyword">return</span> AsyncDestCall(env, req_wrap, args,                       syscall, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, enc,                       after, fn, fn_args...);&#125;</code></pre><p>注意这里有个细节，在 <code>SyncCall</code> 中，会给 fn 的最后一个参数传入 <code>nullptr</code>，<code>AsyncCall</code> 则不会。</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/node-io-another-details.jpeg" alt="又是一个细节"></p><p>而回到上面 <code>writeString</code> 和 <code>writeBuffer</code> 中，最终无论异步同步都是调用 <code>libuv</code>（这个是 node 的 io 库先不展开说了）的 <code>uv_fs_write</code>，只是根据 req 而分别使用 <code>AsyncCall</code> 和 <code>SyncCall</code> 去调用而已。</p><p>下面我们看看 libuv 中的 <a href="https://github.com/nodejs/node/blob/main/deps/uv/src/unix/fs.c#L2152">uv_fs_write</a>：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uv_fs_write</span><span class="hljs-params">(<span class="hljs-keyword">uv_loop_t</span>* loop,</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">uv_fs_t</span>* req,</span></span><span class="hljs-function"><span class="hljs-params">                uv_file file,</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">const</span> <span class="hljs-keyword">uv_buf_t</span> bufs[],</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nbufs,</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">int64_t</span> off,</span></span><span class="hljs-function"><span class="hljs-params">                uv_fs_cb cb)</span> </span>&#123;  INIT(WRITE);  <span class="hljs-keyword">if</span> (bufs == <span class="hljs-literal">NULL</span> || nbufs == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> UV_EINVAL;  req-&gt;file = file;  req-&gt;nbufs = nbufs;  req-&gt;bufs = req-&gt;bufsml;  <span class="hljs-keyword">if</span> (nbufs &gt; ARRAY_SIZE(req-&gt;bufsml))    req-&gt;bufs = uv__malloc(nbufs * <span class="hljs-keyword">sizeof</span>(*bufs));  <span class="hljs-keyword">if</span> (req-&gt;bufs == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> UV_ENOMEM;  <span class="hljs-built_in">memcpy</span>(req-&gt;bufs, bufs, nbufs * <span class="hljs-keyword">sizeof</span>(*bufs));  req-&gt;off = off;  POST;&#125;</code></pre><p>这里的 cb 即为上方的回调函数，这里最终调用 POST，我们先看看 POST</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POST                                                                  \</span>  <span class="hljs-keyword">do</span> &#123;                                                                        \    <span class="hljs-keyword">if</span> (cb != <span class="hljs-literal">NULL</span>) &#123;                                                         \      uv__req_register(loop, req);                                            \      uv__work_submit(loop,                                                   \                      &amp;req-&gt;work_req,                                         \                      UV__WORK_FAST_IO,                                       \                      uv__fs_work,                                            \                      uv__fs_done);                                           \      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                                                               \    &#125;                                                                         \    <span class="hljs-keyword">else</span> &#123;                                                                    \      uv__fs_work(&amp;req-&gt;work_req);                                            \      <span class="hljs-keyword">return</span> req-&gt;result;                                                     \    &#125;                                                                         \  &#125;                                                                           \  <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</code></pre><p>这里的 cb 就是前面说的细节： <code>SyncCall</code> 会给最后一个参数传入 <code>nullptr</code>，最终就是在这里利用回调函数判断同步异步</p><p>但是这里突然冒出来几个函数：</p><ul><li><a href="https://github.com/nodejs/node/blob/main/deps/uv/src/unix/fs.c#L1683">uv__fs_work</a> 是处理文件 io 的函数：</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uv__fs_work</span><span class="hljs-params">(struct uv__work* w)</span> </span>&#123;  <span class="hljs-keyword">int</span> retry_on_eintr;  <span class="hljs-keyword">uv_fs_t</span>* req;  <span class="hljs-keyword">ssize_t</span> r;  req = container_of(w, <span class="hljs-keyword">uv_fs_t</span>, work_req);  retry_on_eintr = !(req-&gt;fs_type == UV_FS_CLOSE ||                     req-&gt;fs_type == UV_FS_READ);  <span class="hljs-keyword">do</span> &#123;    errno = <span class="hljs-number">0</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X(type, action)                                                       \</span>  <span class="hljs-keyword">case</span> UV_FS_ #<span class="hljs-meta"># type:                                                        \</span>    r = action;                                                               \    <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">switch</span> (req-&gt;fs_type) &#123;    X(ACCESS, access(req-&gt;path, req-&gt;flags));    X(CHMOD, chmod(req-&gt;path, req-&gt;mode));    X(CHOWN, chown(req-&gt;path, req-&gt;uid, req-&gt;gid));    X(CLOSE, uv__fs_close(req-&gt;file));    X(COPYFILE, uv__fs_copyfile(req));    X(FCHMOD, fchmod(req-&gt;file, req-&gt;mode));    X(FCHOWN, fchown(req-&gt;file, req-&gt;uid, req-&gt;gid));    X(LCHOWN, lchown(req-&gt;path, req-&gt;uid, req-&gt;gid));    X(FDATASYNC, uv__fs_fdatasync(req));    X(FSTAT, uv__fs_fstat(req-&gt;file, &amp;req-&gt;statbuf));    X(FSYNC, uv__fs_fsync(req));    X(FTRUNCATE, ftruncate(req-&gt;file, req-&gt;off));    X(FUTIME, uv__fs_futime(req));    X(LUTIME, uv__fs_lutime(req));    X(LSTAT, uv__fs_lstat(req-&gt;path, &amp;req-&gt;statbuf));    X(LINK, link(req-&gt;path, req-&gt;new_path));    X(MKDIR, mkdir(req-&gt;path, req-&gt;mode));    X(MKDTEMP, uv__fs_mkdtemp(req));    X(MKSTEMP, uv__fs_mkstemp(req));    X(OPEN, uv__fs_open(req));    X(READ, uv__fs_read(req));    X(SCANDIR, uv__fs_scandir(req));    X(OPENDIR, uv__fs_opendir(req));    X(READDIR, uv__fs_readdir(req));    X(CLOSEDIR, uv__fs_closedir(req));    X(READLINK, uv__fs_readlink(req));    X(REALPATH, uv__fs_realpath(req));    X(RENAME, rename(req-&gt;path, req-&gt;new_path));    X(RMDIR, rmdir(req-&gt;path));    X(SENDFILE, uv__fs_sendfile(req));    X(STAT, uv__fs_stat(req-&gt;path, &amp;req-&gt;statbuf));    X(STATFS, uv__fs_statfs(req));    X(SYMLINK, symlink(req-&gt;path, req-&gt;new_path));    X(UNLINK, unlink(req-&gt;path));    X(UTIME, uv__fs_utime(req));    X(WRITE, uv__fs_write_all(req));    <span class="hljs-keyword">default</span>: <span class="hljs-built_in">abort</span>();    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> X</span>  &#125; <span class="hljs-keyword">while</span> (r == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR &amp;&amp; retry_on_eintr);  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">-1</span>)    req-&gt;result = UV__ERR(errno);  <span class="hljs-keyword">else</span>    req-&gt;result = r;  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span> &amp;&amp; (req-&gt;fs_type == UV_FS_STAT ||                 req-&gt;fs_type == UV_FS_FSTAT ||                 req-&gt;fs_type == UV_FS_LSTAT)) &#123;    req-&gt;ptr = &amp;req-&gt;statbuf;  &#125;&#125;</code></pre><ul><li><a href="https://github.com/nodejs/node/blob/main/deps/uv/src/threadpool.c#L261">uv__work_submit</a> 是一个把工作函数（<code>uv__fs_work</code>）和完成回调（<code>uv__fs_done</code>）加入 <code>uv__work</code>结构中，并利用 <code>post</code> 交给线程池，执行一次线程操作的函数</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uv__work_submit</span><span class="hljs-params">(<span class="hljs-keyword">uv_loop_t</span>* loop,</span></span><span class="hljs-function"><span class="hljs-params">                     struct uv__work* w,</span></span><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">enum</span> uv__work_kind kind,</span></span><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">void</span> (*work)(struct uv__work* w),</span></span><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">void</span> (*done)(struct uv__work* w, <span class="hljs-keyword">int</span> status))</span> </span>&#123;  uv_once(&amp;once, init_once);  w-&gt;loop = loop;  w-&gt;work = work;  w-&gt;done = done;  post(&amp;w-&gt;wq, kind);&#125;</code></pre><p>这里简单介绍一下这里的 <a href="https://github.com/nodejs/node/blob/main/deps/uv/src/threadpool.c#L142">post</a>，他把 <code>uv__work</code> 加入进了 <code>wq</code> 链表的表尾，而 <code>wq</code> 是个全局静态变量，进程空间里的所有线程都能读取这个链表。加入之后他通过 <code>uv_cond_signal</code>唤醒一个在等待的线程来处理这个任务，而线程会在 <code>wq</code> 中取出这个 <code>uv__work</code> 并执行，并在完成后通知主线程的 io 执行 cb。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">post</span><span class="hljs-params">(QUEUE* q, <span class="hljs-keyword">enum</span> uv__work_kind kind)</span> </span>&#123;  uv_mutex_lock(&amp;mutex);  <span class="hljs-keyword">if</span> (kind == UV__WORK_SLOW_IO) &#123;    <span class="hljs-comment">/* Insert into a separate queue. */</span>    QUEUE_INSERT_TAIL(&amp;slow_io_pending_wq, q);    <span class="hljs-keyword">if</span> (!QUEUE_EMPTY(&amp;run_slow_work_message)) &#123;      <span class="hljs-comment">/* Running slow I/O tasks is already scheduled =&gt; Nothing to do here.</span><span class="hljs-comment">         The worker that runs said other task will schedule this one as well. */</span>      uv_mutex_unlock(&amp;mutex);      <span class="hljs-keyword">return</span>;    &#125;    q = &amp;run_slow_work_message;  &#125;  QUEUE_INSERT_TAIL(&amp;wq, q);  <span class="hljs-keyword">if</span> (idle_threads &gt; <span class="hljs-number">0</span>)    uv_cond_signal(&amp;cond);  uv_mutex_unlock(&amp;mutex);&#125;</code></pre><p>这里关乎 libuv 的线程池，就不展开太多了，可以理解为异步模式执行工作。</p><ul><li><a href="https://github.com/nodejs/node/blob/main/deps/uv/src/unix/fs.c#L1755">uv__fs_done</a> 是异步 io 结束的回调了，最终调用 req-&gt;cb 即上面的 cb 函数</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uv__fs_done</span><span class="hljs-params">(struct uv__work* w, <span class="hljs-keyword">int</span> status)</span> </span>&#123;  <span class="hljs-keyword">uv_fs_t</span>* req;  req = container_of(w, <span class="hljs-keyword">uv_fs_t</span>, work_req);  uv__req_unregister(req-&gt;loop, req);  <span class="hljs-keyword">if</span> (status == UV_ECANCELED) &#123;    assert(req-&gt;result == <span class="hljs-number">0</span>);    req-&gt;result = UV_ECANCELED;  &#125;  req-&gt;cb(req);&#125;</code></pre><p>到这里基本就清晰了，我们回到 <code>POST</code> 中，这里使用 cb 是否存在判断该 io 操作是否异步，而 cb 存在时利用 <code>uv__work_submit</code> 把操作交给线程池；cb 不存在时就在当前线程（事件循环所在的）直接调用了。这里就是所谓的同步写入，也同时看出是如何异步写入文件的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域到底是怎么回事-四个跨域协定</title>
    <link href="/%E8%B7%A8%E5%9F%9F%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B-%E5%9B%9B%E4%B8%AA%E8%B7%A8%E5%9F%9F%E5%8D%8F%E5%AE%9A/"/>
    <url>/%E8%B7%A8%E5%9F%9F%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B-%E5%9B%9B%E4%B8%AA%E8%B7%A8%E5%9F%9F%E5%8D%8F%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>前面我分别讲解了<a href="https://ben-lau.github.io/%E8%B7%A8%E5%9F%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/">跨域的基本情况和解决方案</a>，和<a href="https://ben-lau.github.io/%E8%B7%A8%E5%9F%9F%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B-CORS%E8%AF%A6%E8%A7%A3/">CORS 到底怎么回事</a>，分别详细介绍了跨域的原因、资源请求限制的问题和方案，也完整、详细地介绍了 CORS 的所有相关内容，以及部分容易出现但难发现的问题方案。</p><p>作为本系列的最后一期，将会讲解剩余的跨域安全部分。前面两篇着重讲解的是 CORS，根本原则是不允许 js 脚本获取跨域资源内容，那其实除此之外还有别的协定如下：</p><ul><li><strong>CORB(Cross-Origin-Read-Blocking)</strong></li><li><strong>COOP(Cross-Origin-Opener-Policy)</strong></li><li><strong>CORP(Cross-Origin-Resource-Policy)</strong></li><li><strong>COEP(Cross-Origin-Embedder-Policy)</strong></li></ul><p>在介绍这些之前，先提一提这些协定的由来</p><h2 id="起因-Spectre"><a href="#起因-Spectre" class="headerlink" title="起因: Spectre"></a>起因: Spectre</h2><p>2018 年 1 月， Google Project Zero 对外发布了文章讲述了三种严重的 CPU 漏洞：</p><ul><li>bounds check bypass (CVE-2017-5753)</li><li>branch target injection (CVE-2017-5715)</li><li>rogue data cache load (CVE-2017-5754)</li></ul><p>前两种又被称为 <code>Spectre</code>，第三种被称为是 <code>Meltdown</code>。<code>Spectre</code> 是一个 2018 年被发现的严重 CPU 漏洞，通过它攻击者可以通过恶意进程获得其他程序在映射内存中的资料内容，具体内容可以看看<a href="https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)">Spectre (security vulnerability)</a></p><p>简单来说，在浏览器上透过 CPU 的一些机制来进行边信道攻击（side channel attack），获取同一进程内不同网站的内存，或者浏览器本身的内存，特别时在使用一些需要和计算机硬件进行交互的 api 时（performance.measureMemory()、JS Self-Profiling API、SharedArrayBuffer）。虽然 chrome、firefox 也通过站点隔离创建堵截漏洞，但是也因此禁用了部分高风险 api。</p><p>因为该漏洞是推测运行机制导致的，需要处理器微码更新堵截，原则上说<strong>只要让不同网站运行在不同进程的而下面就能规避该漏洞</strong>；而要讲的几种跨域协定，目的就是做好<strong>站点隔离（Site Isolation）</strong>，也是由此产生和切入的安全相关协定。</p><h2 id="四个跨域协定"><a href="#四个跨域协定" class="headerlink" title="四个跨域协定"></a>四个跨域协定</h2><h3 id="CORB-Cross-Origin-Read-Blocking"><a href="#CORB-Cross-Origin-Read-Blocking" class="headerlink" title="CORB(Cross-Origin-Read-Blocking)"></a>CORB(Cross-Origin-Read-Blocking)</h3><p>虽然 CORS 已经将跨域资源共享部分限制，但是<code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;img/&gt;</code>等标签还是可以将外部资源加载，例如<code>&lt;img src=&quot;https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf&quot;&gt;</code>，因为浏览器下载前不知道它是否图片资源，所以在下载后会进入渲染进程，这时候就容易被<code>Spectre漏洞</code>获取。</p><p>所以<strong>CORB</strong>其实是一种算法，当浏览器中跨域加载到达渲染进程前，将可疑、敏感的资源进行识别和阻止，而 CORB 通过响应头的<code>content-type</code>进行判断就是一项非常好的方案，但是部分服务可能 content-type 是错误的，这时候 Chrome 会根据内容有一套自己的判断法则，基本原理是获取资源的 MIME type 进行嗅探（sniffing），而后再决定是否套用 CORB。</p><p>但是 Chrome 也存在误判的可能，即资源的响应头中 content-type 其实才是正确的，而这时候可以在响应头中提供<code>X-Content-Type-Options: nosniff</code>，强制让 Chrome 不套用自己的嗅探而是直接使用 content-type。</p><p>实际表现可以参考<a href="https://anforowicz.github.io/xsdb-demo/index.html">这里</a>：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/corb-example.png" alt="被禁止进入渲染进程的资源"></p><p>更多内容可以参考：</p><ul><li><a href="https://chromium.googlesource.com/chromium/src/+/master/services/network/cross_origin_read_blocking_explainer.md">googlesource</a></li><li><a href="https://github.com/whatwg/fetch/issues/681">github</a></li></ul><h3 id="COOP-Cross-Origin-Opener-Policy"><a href="#COOP-Cross-Origin-Opener-Policy" class="headerlink" title="COOP(Cross-Origin-Opener-Policy)"></a>COOP(Cross-Origin-Opener-Policy)</h3><p>当你在使用<code>window.open</code>时，你可以获取打开新窗口的 window 实例，这时候主窗口可以通过这个实例获取该子窗口的所有变量和更改 location，而子窗口也可以通过<code>window.opener</code>获取主窗口的实例。</p><p>这显然违反了站点隔离，所以 COOP 就是用来解决这个问题，这个响应头<strong>Cross-Origin-Opener-Policy</strong>一共有三个值：</p><ul><li>unsafe-none</li><li>same-origin-allow-popups</li><li>same-origin</li><li>same-origin-allow-popups-plus-coep (目前似乎还在实现，具体可<a href="https://chromestatus.com/feature/5731309970259968">参考这里</a>)</li></ul><p>分别解释一下就是，如果主窗口和子窗口是非同源的站点，那就无法互相获取对方，只能使用部分 api 例如 reload、close 等；如果是同源站点，这时候就分以下几种情况，</p><table><thead><tr><th></th><th align="center">子窗口 unsafe-none</th><th align="center">same-origin-allow-popups</th><th align="center">same-origin</th></tr></thead><tbody><tr><td><b>主窗口 unsafe-none</b></td><td align="center">允许</td><td align="center">不允许</td><td align="center">不允许</td></tr><tr><td><b>same-origin-allow-popups</b></td><td align="center">允许</td><td align="center">允许</td><td align="center">不允许</td></tr><tr><td><b>same-origin</b></td><td align="center">不允许</td><td align="center">不允许</td><td align="center">允许</td></tr></tbody></table><p>我们可以准备代码自己做试验：</p><ul><li><p>准备一个 index.html(主窗口):</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>主窗口<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    index    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">      <span class="hljs-built_in">window</span>.aaa = <span class="hljs-string">&#x27;this is index&#x27;</span>;</span><span class="javascript">      <span class="hljs-built_in">document</span>.body.onclick = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">        <span class="hljs-keyword">const</span> win = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;http://localhost:9999/index2.html&#x27;</span>);</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;index2 instance:&#x27;</span>, win);</span>      &#125;;    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></li><li><p>准备一个 index2.html(子窗口):</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>子窗口<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    index2    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">      <span class="hljs-built_in">window</span>.aaa = <span class="hljs-string">&#x27;this is index2222222&#x27;</span>;</span><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;index1:&#x27;</span>, <span class="hljs-built_in">window</span>.opener);</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></li><li><p>准备一个服务 app.js:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> app = express();app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&#x27;/index.html&#x27;</span>) &#123;    res.header(<span class="hljs-string">&#x27;Cross-Origin-Opener-Policy&#x27;</span>, <span class="hljs-string">&#x27;same-origin&#x27;</span>); <span class="hljs-comment">// 主窗口响应头</span>  &#125;  <span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&#x27;/index2.html&#x27;</span>) &#123;    res.header(<span class="hljs-string">&#x27;Cross-Origin-Opener-Policy&#x27;</span>, <span class="hljs-string">&#x27;same-origin&#x27;</span>); <span class="hljs-comment">// 子窗口响应头</span>  &#125;  next();&#125;);app.use(express.static(<span class="hljs-string">&#x27;.&#x27;</span>));app.listen(<span class="hljs-string">&#x27;9999&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listen in 9999&#x27;</span>);&#125;);</code></pre></li></ul><p>启动后点击 index 的 body，如果允许共享 window 则会发现：</p><ul><li><p>主窗口:<br><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/coop-succ-index.png" alt="主窗口允许"></p></li><li><p>子窗口：<br><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/coop-succ-index2.png" alt="子窗口允许"></p></li></ul><p>如果不允许共享 window，则会出现：</p><ul><li><p>主窗口:<br><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/coop-fail-index.png" alt="主窗口不允许"></p></li><li><p>子窗口：<br><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/coop-fail-index2.png" alt="子窗口不允许"></p></li></ul><p>当然也有现成的<a href="https://first-party-test.glitch.me/coop">COOP 示例</a></p><p>更多具体详情可以<a href="https://github.com/whatwg/html/issues/3740">参考这里</a></p><h4 id="COOP-的小替代品-noopener"><a href="#COOP-的小替代品-noopener" class="headerlink" title="COOP 的小替代品: noopener"></a>COOP 的小替代品: noopener</h4><p>noopener 属性具有与 COOP 的效果类似的效果，只是它只能从打开程序端工作（当窗口被第三方打开时，无法取消关联）。通过执行 <code>window.open(url， &#39;\_blank&#39;， &#39;noopener&#39;)</code> 或 <code>&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;</code> 之类的操作来附加 noopener 时，即可以故意将窗口与打开的窗口断开关联。</p><p>虽然 noopener 可以被 COOP 取代，当想在不支持 COOP 的浏览器中保护站点时，它仍然很有用。</p><h3 id="CORP-Cross-Origin-Resource-Policy"><a href="#CORP-Cross-Origin-Resource-Policy" class="headerlink" title="CORP(Cross-Origin-Resource-Policy)"></a>CORP(Cross-Origin-Resource-Policy)</h3><p>这时候已经有 CORS 保护跨域资源共享，COOP 保护跨域页面实例共享，CORP 阻止可疑资源加载，那如果我服务中有图片、音乐等需要保护呢？这时候就是<strong>Cross-Origin-Resource-Policy</strong>这个响应头负责，这个属性有三个值：</p><ul><li>cross-origin</li><li>same-site</li><li>same-origin</li></ul><p>第一个值是允许跨域资源加载，但是与留空不一样，如果页面配置了<code>Cross-Origin-Embedder-Policy: require-corp</code>，而你的资源没返回<code>Cross-Origin-Resource-Policy: cross-origin</code>，则也不会被加载（后续会说）；same-site 和 same-origin 比较好理解，就是同站（eTLD+1）、同源才允许加载。</p><p>可以利用下面代码测试：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> app = express();app.use(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;  res.header(<span class="hljs-string">&#x27;Cross-Origin-Resource-Policy&#x27;</span>, <span class="hljs-string">&#x27;same-origin&#x27;</span>);  next();&#125;);app.use(express.static(<span class="hljs-string">&#x27;.&#x27;</span>));app.listen(<span class="hljs-string">&#x27;9999&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listen in 9999&#x27;</span>);&#125;);</code></pre><p>这时候只要将服务的链接与引用资源的链接不一致时就会出现：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/corp-example.png" alt="被禁止加载的资源"></p><p>控制台也有提示：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/corp-console-error.png" alt="禁止加载的资源警告"></p><p>这样就可以保护自己的服务资源不被加载，具体可以<a href="https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header">参考这里</a></p><h3 id="COEP-Cross-Origin-Embedder-Policy"><a href="#COEP-Cross-Origin-Embedder-Policy" class="headerlink" title="COEP(Cross-Origin-Embedder-Policy)"></a>COEP(Cross-Origin-Embedder-Policy)</h3><p>这个属性用于告诉浏览器，该站点所有嵌入的资源（img、video、audio、object 等）需要如何校验合法性，它有两个属性：</p><ul><li>unsafe-none</li><li>require-corp</li></ul><p>第一个是默认值，即不做任何限制；第二个(<code>require-corp</code>)意义是：<strong>所有的嵌入跨域资源都是需要 corp 这个响应头且合法</strong>。</p><p>如果站点有响应头<code>Cross-Origin-Embedder-Policy: require-corp</code>，而嵌入的跨域资源没有<code>Cross-Origin-Resource-Policy: cross-origin</code>，则会加载失败且报错：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/cobp-example.png" alt="加载失败的图片"></p><p>控制台也有提示：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/cobp-console-error.png" alt="加载失败的图片警告"></p><p>如果你的 COEP 站点需要的跨域资源确实没有设置 CORP，<strong>这时候也可以给嵌入资源添加<code>crossorigin</code>属性</strong>，如果该资源响应头带合法<code>Access-Control-Allow-Origin</code>属性，也可以正常加载渲染：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://192.168.88.1:9999/pic.jpg&quot;</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span> /&gt;</span></code></pre><h2 id="cross-origin-isolated（跨源隔离）"><a href="#cross-origin-isolated（跨源隔离）" class="headerlink" title="cross-origin isolated（跨源隔离）"></a>cross-origin isolated（跨源隔离）</h2><p>因为 Spectre 漏洞的原因，针对其漏洞特性，浏览器做了以下动作：</p><ul><li>部分 api 会被默认禁用（SharedArrayBuffer）</li><li>减弱了 performance.now() , performance.timeOrigin 的精确性</li></ul><p>而如果你真的需要这些 api 或者精确性的话，则首先要让你的站点开启<strong>cross-origin isolated</strong>（跨源隔离）状态。达到这个状态的条件就是以下两个：</p><ul><li>Cross-Origin-Opener-Policy: same-origin</li><li>Cross-Origin-Embedder-Policy: require-corp</li></ul><p>这时候<strong>self.crossOriginIsolated</strong>属性将会返回<code>true</code>，表明你的站点已成功隔离。为什么需要这样呢？因为设置了这两项，就表明你的站点跨源加载的资源、打开的窗口都应该是有权限的，都已允许或认证，则表面你的站点是安全的；而且这时候通过<a href="https://ben-lau.github.io/%E8%B7%A8%E5%9F%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/#2%E3%80%81document-domain">之前说的</a>修改<code>document.domain</code>绕过同源策略的骚操作就不再可用；这时候你的站点已经成功隔离浏览器 context group。</p><p>可以参考</p><ul><li><a href="https://web.dev/i18n/en/coop-coep/">coop-coep</a></li><li><a href="https://web.dev/i18n/en/why-coop-coep/">why-coop-coep</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下上面说到的四个跨域协定：</p><ul><li>CORB：浏览器的标准协定机制，用于阻止可疑、不合法的资源进入渲染</li><li>COOP：是一个 HTTP headers 的标准，用于帮助严格的 window 实例对象共享规则</li><li>CORP：也是一个 HTTP headers 的标准，可以保护资源不被跨源、跨站的站点加载渲染</li><li>COEP：还是一个 HTTP headers 的标准，确保页面上所有的资源都是合法载入的</li></ul><p>最后通过学习前后三篇的关于跨域的文章，你应该深刻了解到了跨域的整个系统知识和方案，·后续也应该对这些问题刀过竹解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>前端</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域到底是怎么回事-CORS详解</title>
    <link href="/%E8%B7%A8%E5%9F%9F%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B-CORS%E8%AF%A6%E8%A7%A3/"/>
    <url>/%E8%B7%A8%E5%9F%9F%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B-CORS%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="CORS-Cross-Origin-Resource-Sharing"><a href="#CORS-Cross-Origin-Resource-Sharing" class="headerlink" title="CORS(Cross-Origin Resource Sharing)"></a>CORS(Cross-Origin Resource Sharing)</h2><p>很多人可能会混淆，觉得 CORS 是安全协议之类的，其实不然，<a href="https://developer.mozilla.org/en-US/docs/Glossary/CORS">CORS</a>（Cross-Origin Resource Sharing，跨域资源共享）其实是一个系统，由一些列 HTTP headers 组成，这些 HTTP headers 决定了浏览器是否阻止前端 js 代码获取跨域请求的响应。就是一种提供给服务端，让其绕过 <strong>SOP（Same-origin policy，同源策略）</strong>，允许跨域请求访问到它的资源的方法，因为<strong>同源策略</strong>是已经默认阻止了跨域请求响应。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a>机制使 web 应用能进行跨域资源共享，使得跨源数据传输得以安全传输。</p><h3 id="CORS-相关-headers"><a href="#CORS-相关-headers" class="headerlink" title="CORS 相关 headers"></a>CORS 相关 headers</h3><ul><li><code>Origin</code>: 指请求发起方域</li><li><code>Access-Control-Request-Headers</code>：用于预检请求，告知服务器实际请求会有哪些自定义头部字段</li><li><code>Access-Control-Request-Method</code>：用于预检请求，告知服务器实际请求会使用哪一种方法</li><li><code>Access-Control-Allow-Origin</code>：指请求资源允许跟哪些域共享</li><li><code>Access-Control-Allow-Credentials</code>：指是否允许浏览器发送包含凭据的请求</li><li><code>Access-Control-Allow-Headers</code>：指实际请求允许使用的自定义请求头</li><li><code>Access-Control-Allow-Methods</code>：指实际请求允许使用的请求方法</li><li><code>Access-Control-Expose-Headers</code>：指允许 js 获取的响应头部中的字段</li><li><code>Access-Control-Max-Age</code>：指预检请求的结果在多少秒内有效</li></ul><h2 id="跨域请求的过程"><a href="#跨域请求的过程" class="headerlink" title="跨域请求的过程"></a>跨域请求的过程</h2><p>在讲 CORS 前，其实需要先了解整个跨域请求的过程是怎样的。而跨域请求又可以分为简单请求和非简单请求，下面我们先详细说说这两者的异同</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>当你的请求完全符合以下所有条件，即视为简单请求：</p><ul><li>请求 methods 为 GET 、 POST、 HEAD 之一</li><li>请求头中，除了自动设置的字段（如 <code>Connection</code>、<code>User-Agent</code> 等）外，可人为配置的请求头只包含 <code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code></li><li>请求头中，<code>Content-Type</code> 只能是 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code> 之一</li></ul><p>如果你发出的请求被浏览器定义为简单请求（因 WebKit Nightly 和 Safari Technology Preview 都对部分 headers 字段增加了额外限制，非规范的一部分），则你本次请求就不会发送<strong>预检请求（Preflight Request）</strong>，所以请求会成功发送并到达服务器，服务将对其做自己的判断并响应，如果响应头中不包含<strong>Access-Control-Allow-Origin</strong>或者该属性值不包含当前域名，则会被<strong>阻止获取响应内容</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> app = express();app.post(<span class="hljs-string">&#x27;/info&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;  res.setHeader(<span class="hljs-string">&#x27;access-control-allow-origin&#x27;</span>, req.headers.origin || <span class="hljs-string">&#x27;*&#x27;</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;post info&#x27;</span>);  res.end(<span class="hljs-string">&#x27;post&#x27;</span>);&#125;);</code></pre><p>可以在本地起一个简单的服务看到，这次请求是能切实到达服务器的，只是浏览器阻止了 js 对响应的获取。</p><h3 id="非简单请求（复杂请求）"><a href="#非简单请求（复杂请求）" class="headerlink" title="非简单请求（复杂请求）"></a>非简单请求（复杂请求）</h3><p>当你发送的请求不符合简单请求时，就会视为非简单请求。非简单请求将会在真正请求发送前，发送一条<strong>预检请求（Preflight Request）</strong>，目的是获取服务器对该次跨域请求是否允许的前置判断。</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/cors-preflight-request.png" alt="预检请求"></p><p>预检请求将会是 OPTIONS 方法，在请求头上会带上<strong>Access-Control-Request-Method</strong>告知服务器本次实际请求的方法，以及<strong>Access-Control-Request-Headers</strong>告知服务器本次实际请求包含的自定义头部字段，然后由服务器决定该实际请求是否被允许。</p><p>浏览器端：</p><pre><code class="hljs javascript"><span class="hljs-comment">// browser</span>fetch(<span class="hljs-string">&#x27;http://192.168.153.230:9999/info&#x27;</span>, &#123;  method: <span class="hljs-string">&#x27;post&#x27;</span>,  headers: &#123;    aab: <span class="hljs-string">&#x27;aab&#x27;</span>,  &#125;,&#125;);</code></pre><p>服务端：</p><pre><code class="hljs javascript"><span class="hljs-comment">// server</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> app = express();app.options(<span class="hljs-string">&#x27;/info&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;  res.setHeader(<span class="hljs-string">&#x27;access-control-allow-origin&#x27;</span>, req.headers.origin || <span class="hljs-string">&#x27;*&#x27;</span>);  res.setHeader(    <span class="hljs-string">&#x27;access-control-allow-headers&#x27;</span>,    req.headers[<span class="hljs-string">&#x27;access-control-request-headers&#x27;</span>] || <span class="hljs-string">&#x27;&#x27;</span>  );  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;options&#x27;</span>);  res.sendStatus(<span class="hljs-number">204</span>);&#125;);app.post(<span class="hljs-string">&#x27;/info&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;  res.setHeader(<span class="hljs-string">&#x27;access-control-allow-origin&#x27;</span>, req.headers.origin || <span class="hljs-string">&#x27;*&#x27;</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;post info&#x27;</span>);  res.end(<span class="hljs-string">&#x27;post&#x27;</span>);&#125;);</code></pre><p>可以在本地起一个服务去发送次请求，带上一个自定义头部（aab），然后能查看 devtool 中的 network：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/cors-options.jpg" alt="预检请求"></p><p>可以看到的是，我们即使在 post 响应中，不返回<code>access-control-allow-headers</code>，只在 options 响应中返回，该跨域请求也是可以成功获取响应的。但是如果 options 响应中缺失<code>access-control-allow-origin</code>，则真实请求则<strong>不会发出</strong>；如果是真实请求响应中缺失<code>access-control-allow-origin</code>，则该请求<strong>无法获取响应</strong>。</p><p>所以预检请求必须返回正确的<code>access-control-allow-origin</code>、<code>access-control-allow-headers</code>、<code>access-control-allow-methods</code>，本次真实请求才能被发出。而真实请求必须返回正确的<code>access-control-allow-origin</code>，该请求才能被获取响应。</p><p>综上可知，跨域请求中如果是简单请求则<strong>拦截响应</strong>，非简单请求则是有可能<strong>拦截请求</strong>或者<strong>拦截响应</strong>。</p><h2 id="设置预检请求缓存"><a href="#设置预检请求缓存" class="headerlink" title="设置预检请求缓存"></a>设置预检请求缓存</h2><p>要知道，每次非简单的跨域请求都会发送一次预检请求，而业务中很常见的就是 post 一个 json 数据，那多次请求的话，服务器也需要校验，多多少少还是增加了服务压力。</p><p>这时候可以在响应头上设置<strong>access-control-max-age</strong>，值是秒数</p><pre><code class="hljs javascript">app.options(<span class="hljs-string">&#x27;/info&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;  res.setHeader(<span class="hljs-string">&#x27;access-control-allow-origin&#x27;</span>, req.headers.origin || <span class="hljs-string">&#x27;*&#x27;</span>);  res.setHeader(    <span class="hljs-string">&#x27;access-control-allow-headers&#x27;</span>,    req.headers[<span class="hljs-string">&#x27;access-control-request-headers&#x27;</span>] || <span class="hljs-string">&#x27;&#x27;</span>  );  res.setHeader(<span class="hljs-string">&#x27;access-control-max-age&#x27;</span>, <span class="hljs-number">60</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;options&#x27;</span>);  res.sendStatus(<span class="hljs-number">204</span>);&#125;);</code></pre><p>那么在设置的时间内，同样的资源请求将不再发送预检请求，减少了服务压力。</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/cors-max-age.png" alt="预检请求缓存"></p><h2 id="包含凭据的跨域请求"><a href="#包含凭据的跨域请求" class="headerlink" title="包含凭据的跨域请求"></a>包含凭据的跨域请求</h2><p>跨域请求中，默认是不会带上身份凭据(cookies)的，而真实业务中往往需要上传 cookie 验证，这时候你可能会在 <code>XMLHttpRequest</code>中加上<code>withCredentials = true</code>，获取<code>fetch</code>中加上<code>credentials: &#39;include&#39;</code>，然后你会得到其中一条报错：</p><ul><li><code>The value of the &#39;Access-Control-Allow-Credentials&#39; header in the response is &#39;&#39; which must be &#39;true&#39; when the request&#39;s credentials mode is &#39;include&#39;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</code></li><li><code>Response to preflight request doesn&#39;t pass access control check: The value of the &#39;Access-Control-Allow-Credentials&#39; header in the response is &#39;&#39; which must be &#39;true&#39; when the request&#39;s credentials mode is &#39;include&#39;. </code></li></ul><p>这时候我们需要将<strong>access-control-allow-credentials</strong>设置为<code>&#39;true&#39;</code>，再试一次，获得了另一个报错：</p><p><code>The value of the &#39;Access-Control-Allow-Origin&#39; header in the response must not be the wildcard &#39;*&#39; when the request&#39;s credentials mode is &#39;include&#39;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute</code></p><p>这是因为当<strong>access-control-allow-credentials</strong>为<code>&#39;true&#39;</code>时，<strong>access-control-allow-origin</strong>将必须为正确的请求发起 url，不能为*。所以这时候将<strong>access-control-allow-origin</strong>返回请求时的 origin 即可。</p><p>这时候就能将 cookie 提交了。</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/cors-cookie.png" alt="cookie"></p><h2 id="获取自定义-header"><a href="#获取自定义-header" class="headerlink" title="获取自定义 header"></a>获取自定义 header</h2><p>在响应头上，可能会带有服务端返回的字段，这些字段默认是不允许 js 读取的，但是如果需要怎么办呢。也是需要在响应头上加入<strong>access-control-expose-headers</strong>，该属性能定义哪些响应头字段允许被 js 读取。</p><pre><code class="hljs javascript">app.post(<span class="hljs-string">&#x27;/info&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;  res.setHeader(<span class="hljs-string">&#x27;access-control-allow-origin&#x27;</span>, req.headers.origin || <span class="hljs-string">&#x27;*&#x27;</span>);  res.setHeader(<span class="hljs-string">&#x27;access-control-expose-headers&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>);  res.setHeader(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;post info&#x27;</span>);  res.end(<span class="hljs-string">&#x27;post&#x27;</span>);&#125;);</code></pre><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/cors-expose-headers.jpg" alt="headers"></p><p>这样，就能在 js 中获取允许导出的头部字段了</p><h2 id="跨域请求缓存问题"><a href="#跨域请求缓存问题" class="headerlink" title="跨域请求缓存问题"></a>跨域请求缓存问题</h2><p>最后说一种比较特殊的情况，就是有这么一个场景：有一个上传图片的功能，上传后显示预览效果（img 标签显示），然后图片又要能编辑，编辑就需要 js 请求加载，这时候你会发现请求报出了跨域。</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/cors-image-cache.jpg" alt="请求缓存跨域"></p><p>明明添加了<code>access-control-allow-origin</code>，为什么还是报了跨域错误呢？其实这里的问题出现在，大部分的服务都是请求时头部如果没<code>Origin</code>字段，是不会返回<code>access-control-allow-origin</code>的，而图片的服务恰好都是强缓存，这时候因为 img 标签显示是没有跨域问题，也不会添加<code>Origin</code>字段</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/cors-img.jpg" alt="img标签请求"></p><p>而响应头又没有<code>access-control-allow-origin</code>，而恰好又被缓存了，这时候再请求同资源，浏览器将优先获取缓存，而因为缓存中的响应头没添加 CORS 相关头部，所以就报了跨域错误。</p><p>该如何解决呢，其实有三种方案：</p><ul><li>1、给请求添加 search 参数，即给请求添加了任意一个<code>?v=123</code>之类的参数字段，这样请求将会重新发出不用缓存</li><li>2、给<code>img</code>标签添加<code>crossorigin</code>属性，这样浏览器对该图片的请求会带上<code>Origin</code></li><li>3、给响应头加入 Vary 字段，该属性用于决定后续请求需要匹配哪些信息才能使用缓存。例如<code>Vary: Origin</code>，则后续请求如果<code>Origin</code>字段不一致则不使用请求，当然你也可以设置成<code>Vary: *</code>，但是这样用<code>Cache-Control</code>控制会更直观。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，你应该也对 CORS 有个深入的了解了，但是浏览器的跨域安全管理仅仅如此吗？</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>Javascript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域是怎么回事</title>
    <link href="/%E8%B7%A8%E5%9F%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/"/>
    <url>/%E8%B7%A8%E5%9F%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="跨域是怎么回事"><a href="#跨域是怎么回事" class="headerlink" title="跨域是怎么回事"></a>跨域是怎么回事</h1><h2 id="从一个常见的问题开篇"><a href="#从一个常见的问题开篇" class="headerlink" title="从一个常见的问题开篇"></a>从一个常见的问题开篇</h2><p><code>request has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code></p><p>相信上面的错误很多时候都能碰到，一般发生在前端发起请求时，而可能很多开发都不知道怎么解决，甚至是谁去解决。其实这个就是比较典型的跨域访问问题，而绝大部分这种情况，都不是单纯靠前端能解决的，因为禁止跨域访问原本就是 web 安全规范的一项，如果纯前端能绕过去，那还有什么安全意义呢？</p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>通常说的跨域（cross origin），其实指的是<strong>跨不同源的资源请求，而浏览器会对非同源的请求进行安全性限制</strong>，这源自于浏览器的<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">同源策略（Same-origin policy）</a>约定，从而一定程度上提升了浏览器的安全和提高了攻击成本。</p><p>那什么是不同源呢？可以将一个资源地址看成是 scheme + host + port + path 的组合：</p><pre><code class="hljs vim">http<span class="hljs-variable">s:</span>//<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span>:<span class="hljs-number">8888</span>/home/<span class="hljs-built_in">index</span>scheme|  host  |port|   path   |https 是协议<span class="hljs-keyword">abc</span>.<span class="hljs-keyword">com</span> 是域名<span class="hljs-number">8888</span> 是端口home/<span class="hljs-built_in">index</span> 是路径</code></pre><p>下面用 <code>https://abc.com/home/index</code> 作为例子发出了如下几种请求:</p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><a href="https://abc.com/index">https://abc.com/index</a></td><td>成功</td><td>只是路径不同</td></tr><tr><td><a href="http://abc.com/home/index">http://abc.com/home/index</a></td><td>失败</td><td>协议不同</td></tr><tr><td><a href="https://a.abc.com/home/index">https://a.abc.com/home/index</a></td><td>失败</td><td>域名不同</td></tr><tr><td><a href="https://abc.com:8888/home/index">https://abc.com:8888/home/index</a></td><td>失败</td><td>端口不同</td></tr></tbody></table><p>而在 IE 中，未将端口纳入同源策略的检查中，所以上面的最后一个在 IE 中并不受限制。</p><p>可组合性是 Web 非常强大的一项能力，让 Web 可以随时加载不同来源的资源以增强自身功能，包含字体、图片、音视频、脚本等。但是强大的策略同样会带来信息泄露的风险，攻击者很容易能利用漏洞获取用户的信息，但是浏览器在安全方面也做的很好，这个就是同源策略。而同源策略所限制的交互包含以下 3 类：</p><ul><li>跨域网络访问：包含 XMLHttpRequest、fetch 或者<code>&lt;script&gt;、&lt;link&gt;、&lt;img&gt;、&lt;video&gt;、&lt;audio&gt;、&lt;object&gt;、&lt;embed&gt;、&lt;iframe&gt;</code>等引入的资源。</li><li>跨域 dom、api 访问：主要是 iframe 的内容和 window.open 后的内容限制。</li><li>跨域数据存储访问：包含 cookie、localStorage 和 IndexedDB。</li></ul><h2 id="同源策略的意义"><a href="#同源策略的意义" class="headerlink" title="同源策略的意义"></a>同源策略的意义</h2><p>可能在日常开发中，用 link 标签、script 标签、img 标签引入一些外部资源很常见，而且似乎也没出过问题，并且 form 里的 action 好像也可以跨域发送，为什么换成 js 请求（xmlhttprequest、fetch 等）就不行呢？</p><h3 id="如果没有同源接口请求限制"><a href="#如果没有同源接口请求限制" class="headerlink" title="如果没有同源接口请求限制"></a>如果没有同源接口请求限制</h3><p>现在你的公司内网有些内部服务在跑，外部攻击者即使没有同源策略外部也无法访问，这个很安全。但是如果攻击者做一个攻击网站，想办法让你打开，请求你的内部 ip 上的服务，然后获取结果再返回到攻击者服务器里，这就能窃取到你公司内网内的信息了。你可能觉得获取内部的地址很难，如果我是直接遍历请求<code>localhost:</code>所有端口呢？这样子就能拿到所有你跑在 localhost 里的内容了。</p><h3 id="如果没有同源-dom-限制"><a href="#如果没有同源-dom-限制" class="headerlink" title="如果没有同源 dom 限制"></a>如果没有同源 dom 限制</h3><p>假如有个银行网站叫<code>yinhang.com</code>，然后攻击者做了个钓鱼的网站叫<code>yinghang.com</code>，内部用 iframe 嵌入了<code>yinhang.com</code>。因为你的疏忽没看清地址，进入了钓鱼网站并登录了，而攻击者的网站又能畅通无阻地获取 iframe 内所有 dom 和对象，那你的账号密码将直接暴露给攻击者了。</p><h3 id="如果没有同源存储访问"><a href="#如果没有同源存储访问" class="headerlink" title="如果没有同源存储访问"></a>如果没有同源存储访问</h3><p>这个就更恐怖了，大量的登录 token 放在 cookie，只要你登录过银行账号等，攻击者的网站就能直接向银行接口发起请求并且带上你的银行账号 token 的 cookie，然后做任何他想做的事.</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>其实说到底是个安全性的问题。</p><p>那你可能会好奇为什么前者允许：因为这些资源对于浏览器来说，属于页面内容、网页资源的一部分，而且浏览器会将各个站点的不同资源放在不同的 <code>Context Group</code> 下，不同的 <code>Context Group</code> 下的资源无法互相访问。所以你放在标签内的图片等，可以展示，但是 js 无法读取，而无法得知其内容也无法将其传到别的地方，所以这里也没有外泄的问题。</p><p>而 <code>form</code> 表单中 <code>action</code> 其实也没有跨域问题，因为原页面使用 form 传送信息给新页面后，原页面 js 无法获取结果，所以浏览器也是觉得安全的。其实总结来说就是，浏览器本质上并不阻止你发送请求和信息，只是在未经许可前，不允许你获取返回的结果而已。</p><p>所以同源策略是非常必要且有意义的，像平时开发中遇到<a href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%BC%80%E7%AF%87">开篇中那种常见的问题</a>之类的跨域问题，<strong>基本都不是前端的问题，而且纯前端手段是无法解决的</strong>。因为如果能用前端脚本手段绕过，那安全何在呢？但是并不代表前端就可以不了解这块了。而<strong>同源策略</strong>也仅仅只是限制了浏览器环境，如果是服务端之类的就没有这个问题。</p><h2 id="如何解决跨域-dom、api-访问？"><a href="#如何解决跨域-dom、api-访问？" class="headerlink" title="如何解决跨域 dom、api 访问？"></a>如何解决跨域 dom、api 访问？</h2><p>在了解了跨域问题后，可能你需要在主页面打开新窗口，或者创建 iframe，并且获取其信息，那需要如何解决呢？</p><h3 id="1、postMessage"><a href="#1、postMessage" class="headerlink" title="1、postMessage"></a>1、postMessage</h3><p>window.postMessage() 是 HTML5 的 api，利用它可以实现主页面和其打开的新窗口通信、创建的 iframe 通信：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> childWindow = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;http://localhost:8080/app2.html&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>);<span class="hljs-comment">// 第一个参数为传递信息，第二个参数为目标origin</span>childWindow.postMessage(<span class="hljs-string">&#x27;hello word&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:8080/app2.html&#x27;</span>);</code></pre><p>子页面可以监听<code>message</code>事件来获取信息</p><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(  <span class="hljs-string">&#x27;message&#x27;</span>,  e =&gt; &#123;    <span class="hljs-built_in">console</span>.log(e.source); <span class="hljs-comment">// 发送信息的窗口</span>    <span class="hljs-built_in">console</span>.log(e.origin); <span class="hljs-comment">// 信息发向的网址</span>    <span class="hljs-built_in">console</span>.log(e.data); <span class="hljs-comment">// 发送的信息</span>  &#125;,  <span class="hljs-literal">false</span>);</code></pre><h3 id="2、document-domain"><a href="#2、document-domain" class="headerlink" title="2、document.domain"></a>2、document.domain</h3><p>这个方法只适合主域名相同的情况，例如<code>aaa.com</code>打开了<code>www.aaa.com</code>页面，这种情况下，可以修改<code>document.domain</code>为<code>aaa.com</code>，如此就可以访问对方的 window 对象以及其执行的所有对象了。</p><h2 id="如何解决跨域请求？"><a href="#如何解决跨域请求？" class="headerlink" title="如何解决跨域请求？"></a>如何解决跨域请求？</h2><p>除了跨域 dom、api 等对象访问以外，还有就是跨域请求访问。如果还是需要给不同源的地址发送请求，那需要怎么解决同源策略这个问题呢？</p><p>其实方法有很多，可以先列举几个的方法：</p><h3 id="1、关闭浏览器的安全设置"><a href="#1、关闭浏览器的安全设置" class="headerlink" title="1、关闭浏览器的安全设置"></a>1、关闭浏览器的安全设置</h3><p>同源策略本质上只是浏览器做的限制，所以只要关闭了这个限制就可以，不过这个仅仅只对自己的设备，是个治标不治本的方案。具体各个浏览器如何关闭可以自行搜索。</p><h3 id="2、将-fetch-mode-设为-no-cors"><a href="#2、将-fetch-mode-设为-no-cors" class="headerlink" title="2、将 fetch mode 设为 no-cors"></a>2、将 fetch mode 设为 no-cors</h3><p>fetch 方法里有个参数 mode，可以将其设置成<code>no-cors</code></p><pre><code class="hljs javascript">fetch(<span class="hljs-string">&#x27;http://localhost:9999/info&#x27;</span>, &#123;  mode: <span class="hljs-string">&#x27;no-cors&#x27;</span>,  method: <span class="hljs-string">&#x27;POST&#x27;</span>,&#125;)  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(res);    <span class="hljs-keyword">return</span> res.text();  &#125;)  .then(<span class="hljs-built_in">console</span>.log);</code></pre><p>我们本地起个服务试试，本身会跨域的请求，加上这个参数后会打印出：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/fetch-mode-no-cors.jpg" alt="fetch的mode为no-cors打印结果"></p><p>可以看到状态码为 0，type 为 <code>opaque</code>，拿到的请求返回为空，但是控制台没任何报错。在控制台的 network 内又能看到正确返回。</p><p>因为<a href="https://fetch.spec.whatwg.org/#concept-request-mode">mode: ‘no-cors’</a>并非解决了跨域问题，而是告诉浏览器你需要发送一个跨域请求，并且你确实不关心返回。如此，这次请求不会报任何错误，但是也不会返回任何信息到 js 里，即使已经设置了 Access-Control-Allow-Origin 的 header。所以这个设置只是<strong>在某些场合下可用</strong>而已，并非真正解决跨域请求问题。</p><h3 id="3、不使用-ajax-获取数据"><a href="#3、不使用-ajax-获取数据" class="headerlink" title="3、不使用 ajax 获取数据"></a>3、不使用 ajax 获取数据</h3><p>不是用 ajax 发出的请求确实就没有这种限制了，那考虑到的就是 html 标签和 form 表单。</p><p>当我们发送请求时，变成创建一个<code>script</code>标签，那这种请求就不会受同源策略限制：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 前端</span><span class="hljs-keyword">const</span> request = <span class="hljs-function">(<span class="hljs-params">url, data, cb</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">10</span> ** <span class="hljs-number">10</span>);  <span class="hljs-keyword">const</span> callbackName = <span class="hljs-string">`callback<span class="hljs-subst">$&#123;id&#125;</span>`</span>;  <span class="hljs-keyword">const</span> urlSearchParams = <span class="hljs-keyword">new</span> URLSearchParams();  <span class="hljs-comment">// 将回调函数名告诉服务端</span>  urlSearchParams.set(<span class="hljs-string">&#x27;callbackName&#x27;</span>, callbackName);  <span class="hljs-comment">// 组装参数到url中</span>  <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;    urlSearchParams.set(key, data[key]);  &#125;);  <span class="hljs-comment">// 创建script标签</span>  <span class="hljs-keyword">const</span> $script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);  $script.src = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;urlSearchParams.toString()&#125;</span>`</span>;  <span class="hljs-comment">// 设置临时回调函数，触发callback并删除临时回调函数本身</span>  <span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    cb(data);    <span class="hljs-built_in">window</span>[callbackName] = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">delete</span> <span class="hljs-built_in">window</span>[callbackName];  &#125;;  <span class="hljs-comment">// 插入dom中，利用html资源能力发送</span>  <span class="hljs-built_in">document</span>.body.append($script);&#125;;request(<span class="hljs-string">&#x27;localhost:9999/info&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;guy&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;2021&#x27;</span> &#125;, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;获取数据:&#x27;</span>, data);&#125;);</code></pre><p>利用<code>script</code>标签绕过跨域问题发送出请求，最后需要服务端响应这次请求并且返回一个 js 可执行代码，触发我们定义好的临时回调函数并将数据插入：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 服务端</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> app = express();app.get(<span class="hljs-string">&#x27;/info&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> id = req.query.id;  <span class="hljs-keyword">const</span> name = req.query.name;  <span class="hljs-keyword">const</span> callbackName = req.query.callbackName;  <span class="hljs-comment">// 返回可执行代码，触发临时回调函数，并将数据传入</span>  res.end(<span class="hljs-string">`<span class="hljs-subst">$&#123;callbackName&#125;</span>(<span class="hljs-subst">$&#123;id&#125;</span>,<span class="hljs-subst">$&#123;name&#125;</span>)`</span>);&#125;);</code></pre><p>这样就是简单的不使用 ajax 发送请求方法了，这也是大名鼎鼎的<strong>JSONP（JSON with Padding）</strong>，这个方法在早期 CORS 规范不完整时非常常用，但是弊端也很明显：只能使用 GET 这个 method，那如何发送其他 method 的请求呢？</p><hr><p>其实可以利用到 form 表单，form 本身无跨域问题，也支持多种 methods，只是提交后会刷新，那我们只需创建一个 iframe，并且让 form 提交后刷新这个 iframe 而非主页面即可。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request = <span class="hljs-function">(<span class="hljs-params">url, data, cb</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> $iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;iframe&#x27;</span>);  $iframe.name = <span class="hljs-string">&#x27;request&#x27;</span>;  $iframe.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;  <span class="hljs-comment">// 注册iframe的load事件，并且触发回调</span>  $iframe.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, cb);  <span class="hljs-built_in">document</span>.body.appendChild($iframe);  <span class="hljs-keyword">const</span> $form = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;form&#x27;</span>);  $form.action = url;  <span class="hljs-comment">// 在指定的iframe中执行form</span>  $form.target = $iframe.name;  $form.method = <span class="hljs-string">&#x27;post&#x27;</span>;  $form.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;  <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> node = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;input&#x27;</span>);    node.name = key;    node.value = data[key];    $form.appendChild(node);  &#125;);  <span class="hljs-built_in">document</span>.body.appendChild($form);  $form.submit();  <span class="hljs-built_in">document</span>.body.removeChild($form);&#125;;</code></pre><p>这种方法弊端也很明显：就是无法获取返回数据。</p><h3 id="4、代理、转发"><a href="#4、代理、转发" class="headerlink" title="4、代理、转发"></a>4、代理、转发</h3><p>这种方法较为正规，利用了服务端无这种限制的优势，只要代理或者转发的服务域名跟前端域名同源即可：常见的可以前端自行启动服务转发，也可以中间件返回 CORS 配置好的 headers，也可以 nginx 反向代理。</p><p>弊端嘛，就是多了一层服务，增加服务器压力和多多少少减慢了返回速度。</p><h3 id="5、服务端返回-CORS-响应头"><a href="#5、服务端返回-CORS-响应头" class="headerlink" title="5、服务端返回 CORS 响应头"></a>5、服务端返回 CORS 响应头</h3><p>这个才是最正确且常规的做法，也是从根本上一劳永逸地解决了跨域问题，因为这个方案将权限完全交给服务端，服务端来控制是否允许前端获取请求响应。</p><p>弊端的话，可能就是浏览器兼容问题，主要需要 IE10 以上。</p><p>下一篇会详细讲解 CORS。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>前端</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量提升和函数声明提升</title>
    <link href="/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/"/>
    <url>/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h1 id="变量提升和函数声明提升"><a href="#变量提升和函数声明提升" class="headerlink" title="变量提升和函数声明提升"></a>变量提升和函数声明提升</h1><p>关于 Javascript 中的变量提升（variable hoisting）可能在前端界已经耳熟能详了，可能你会觉得设计初衷是什么呢，或者这里有出于什么考虑以及解决了什么问题呢？因为这块“特性”成为了前端人必须了解并绕过的坑，也可能成为了不少前端人的困扰。</p><p>其实根据 Brendan Eich 的说法：<br><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/brendan-erich-answer.png" alt="Brendan Eich本人回复关于变量提升"></p><p>大概意思就是，变量提升是函数提升的意外结果。（手动狗头）</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>下面开始先给几道有趣的题：</p><p>1、</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!(Ben <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>)) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);  <span class="hljs-keyword">var</span> Ben = <span class="hljs-string">&#x27;handsome&#x27;</span>;&#125;<span class="hljs-built_in">console</span>.log(Ben <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>);<span class="hljs-built_in">console</span>.log(Ben);</code></pre><p>2、</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  a = <span class="hljs-number">1</span>;  <span class="hljs-built_in">console</span>.log(a);  <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;    <span class="hljs-built_in">console</span>.log(a);  &#125;  <span class="hljs-built_in">console</span>.log(a);&#125;)();<span class="hljs-built_in">console</span>.log(a);</code></pre><p>3、</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;&#123;  <span class="hljs-built_in">console</span>.log(a);  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;  <span class="hljs-built_in">console</span>.log(a);&#125;</code></pre><p>4、</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(b);  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;  <span class="hljs-built_in">console</span>.log(b);&#125;)();</code></pre><p>5、</p><pre><code class="hljs javascript">&#123;  a = <span class="hljs-number">123</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;&#125;<span class="hljs-built_in">console</span>.log(a);</code></pre><p>6、</p><pre><code class="hljs javascript">&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;  a = <span class="hljs-number">123</span>;&#125;<span class="hljs-built_in">console</span>.log(a);</code></pre><p>7、</p><pre><code class="hljs javascript">&#123;  a = <span class="hljs-number">123</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;  a = <span class="hljs-number">456</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;&#125;<span class="hljs-built_in">console</span>.log(a);</code></pre><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript 代码从开始经过分词（tokenize）、预解析（preparse）、解析（parse），而变量声明在 prepare 时期就完成了。</p><p>可以这么理解，一个变量有着<code>声明</code>、<code>初始化</code>、<code>赋值</code>的过程，而<code>声明</code>会被预解析时就完成并且进入到各自的执行环境中，而 var 在此时将<code>初始化</code>也完成了(undefined)，函数声明则是连<code>赋值</code>也完成了（函数内存地址指向）。</p><ul><li>let、const 提升了<code>声明</code>，并将变量放入词法环境中，这时候值为未初始化（uninitialized），所以不允许使用（暂时性死区）</li><li>var 提升了<code>声明</code>和<code>初始化</code>，并将变量放入变量环境中，这时候值为 undefined</li><li>函数定义提升了<code>声明</code>、<code>初始化</code>和<code>赋值</code>，将函数创建进入堆，并将值改为函数内存地址。</li></ul><p>(可参考<a href="https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-hoisted/31222689#31222689">let、const 是否有变量提升？</a>))</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;  <span class="hljs-keyword">var</span> a;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>); <span class="hljs-comment">// true</span></code></pre><p>这块代码内，window 对象内并没有 a 变量，而且条件为 false 也并不会执行内部代码，但是这段打印确实 true，这里就说明了在代码未解析执行时就已经完成了声明。</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><ol><li><p>题目 1 解析<br>因为 var 声明会在 preparse 时期执行，先于执行语句解析声明变量，且 var 声明作用于函数执行的作用域，所以会穿透 for 和 if 语句。</p></li><li><p>题目 2 解析<br>因为 var 声明会在 preparse 时期执行，先于执行语句解析声明变量，且 var 声明作用于函数执行的作用域，所以会穿透 for 和 if 语句。而 function 是有函数作用域的，所以 iife 内的 a 变量为私有，所以内部都会打印 1，函数外的 a 因未被赋值所以 undefined。</p></li><li><p>题目 3 解析<br>因为 var 不进入块语句中的词法环境，并且会提升，而且对于 var 来说没块级作用域。</p></li><li><p>题目 4 解析<br>这里就是因为函数作用域的问题，但是为什么第一个打印还是 undefined，因为 javascript 寻找变量顺序是当前作用域一直向上寻找，而这里因为变量提升所以在 iife 函数中声明了私有变量，但是未赋值，所以为 undefined。</p></li></ol><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>函数定义说的是 function 定义的函数（<code>function func()&#123;&#125;</code>），而不是匿名函数（<code>var func = function()&#123;&#125;</code>）赋值。而 function 定义不在块语句中（<code>&#123;&#125;</code>）的话，它会在预解析时声明、初始化、赋值。</p><p>而 function 定义如果在块语句中的话，包括 if/for/try/with 等，在 ES3 标准中，预解析，都会将 function 的声明和初始化和赋值都会提升到块语句外层；而 ES6 标准后，块语句中 function 的提升只是声明和初始化，并不赋值。而<strong>为了兼容旧标准，块语句中的 function 会将执行时，将当前块语句中的<code>变量环境</code>映射一份到外层上下文中，使得外层拥有了 function 语句这一行以上的所有变量的赋值，而后面的所有变量都不会被提升，成为了当前块语句的私有变量</strong>。</p><p>而上面的题目 5、6、7 就是典型的例子，其实如果只要劫持一下 window 的属性，就会知道是否赋值了（<strong>因为 var 提升会将变量定义到 window 内，而 let、const 并不会，即使是全局定义的 let、const 也不进入到 window 对象内的属性</strong>）</p><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;  set(e) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setA&#x27;</span>, e);  &#125;,&#125;);&#123;  a = <span class="hljs-number">123</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;  a = <span class="hljs-number">456</span>;&#125;<span class="hljs-comment">// setA 123</span>&#123;  a = <span class="hljs-number">123</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;  a = <span class="hljs-number">456</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;&#125;<span class="hljs-comment">// setA 123</span><span class="hljs-comment">// setA 456</span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;  a = <span class="hljs-number">123</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;  a = <span class="hljs-number">456</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;  a = <span class="hljs-number">789</span>;&#125;<span class="hljs-comment">// setA f a()&#123;&#125;</span><span class="hljs-comment">// setA 123</span><span class="hljs-comment">// setA 456</span></code></pre><p>大概解析如下：<br><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/function-hoist.png" alt="块语句内函数定义"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里能看出 var 和 function 因为历史原因或者新旧标准的原因导致了多个奇怪的问题，所以在平时开发工作中，也应该尽量使用 let 和 const。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行上下文和作用域</title>
    <link href="/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="执行上下文和作用域"><a href="#执行上下文和作用域" class="headerlink" title="执行上下文和作用域"></a>执行上下文和作用域</h1><p><code>执行上下文</code>是一个描述代码运行时所在环境的抽象概念，JavaScript 引擎再开始执行代码前，会创建全局执行上下文 ，全局代码（不属于任何函数的代码）在全局执行上下文中执行。 全局执行上下文 在每个 JS 程序中只有一个。</p><p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中（execution stack）。在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个便利的机制控制着。</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>因为 JavaScript 是个单线程语言，这意味着同一时间只能执行一个任务，而 JavaScript 内部原理又会经过<code>分词（tokenize）</code>、<code>预解析（preparse）</code>、<code>解析（parse）</code>，这里不展开讲。解析执行的时候有三种情况生成执行上下文（execution context）：全局代码、函数代码，eval 代码。</p><p>在 ES3 中，执行上下文中包含：</p><ul><li><code>作用域链（scope)</code></li><li><code>变量对象（variable object）</code></li><li><code>this</code></li></ul><p>在 ES5 中，变成了包含:</p><ul><li><code>词法环境（lexical environment）</code>（作用域）</li><li><code>变量环境（variable environment）</code></li><li><code>this</code></li></ul><p>可参考<a href="https://262.ecma-international.org/5.1/#sec-10.3">ECMA262 规范</a>。</p><p>再后来（ES8），this 值被归入了词法环境中：</p><ul><li><code>词法环境，包含this，获取变量时使用（lexical environment）</code>（作用域）</li><li><code>变量环境，声明变量时使用（variable environment）</code></li><li><code>代码执行状态（code evaluation state）</code></li><li><code>正在执行的函数（Function）</code></li><li><code>正在被执行的代码（ScriptOrModule）</code></li><li><code>内置对象实例（Realm）</code></li><li><code>当前生成器，只有生成器上下文才有（Generator）</code></li></ul><h3 id="VO-和-AO"><a href="#VO-和-AO" class="headerlink" title="VO 和 AO"></a>VO 和 AO</h3><p><code>变量对象（variable object）</code>的属性由变量和函数声明构成，每一个执行上下文都会被分配一个变量对象，而在函数上下文情况下，参数列表也会被加入到变量对象中。</p><p><code>活动对象（activation object）</code>会在函数被激活时就会被创建并分配给执行上下文。</p><p>在函数执行上下文中，VO 是不能直接访问的，而 AO 是可以访问的。</p><p>可以用以下代码举例说明：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFun</span>(<span class="hljs-params">arg1, arg2</span>) </span>&#123;  <span class="hljs-keyword">var</span> value1 = <span class="hljs-number">1</span>;  <span class="hljs-keyword">var</span> value2 = <span class="hljs-number">2</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> innerV1 = <span class="hljs-number">3</span>;    <span class="hljs-keyword">var</span> innerV2 = <span class="hljs-number">4</span>;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;1&#x27;</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;2&#x27;</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">value2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;3&#x27;</span>;  &#125;&#125;outerFun();</code></pre><p>他的变量对象创建是这样的：</p><table><thead><tr><th align="center">key</th><th align="center">value</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">arguments</td><td align="center">Arguments Object</td><td align="center">检查当前执行上下文的参数列表，创建 arguments 对象</td></tr><tr><td align="center">func1</td><td align="center">&lt;func1() reference&gt;</td><td align="center">检查到 function 声明，属性值指向函数所在的内存地址</td></tr><tr><td align="center">func2</td><td align="center">&lt;func2() reference&gt;</td><td align="center"></td></tr><tr><td align="center">value1</td><td align="center">undefined</td><td align="center">检查到执行上下文的所有 var 声明 并建立属性</td></tr><tr><td align="center">value2</td><td align="center">undefined</td><td align="center"></td></tr></tbody></table><h3 id="词法环境和变量环境"><a href="#词法环境和变量环境" class="headerlink" title="词法环境和变量环境"></a>词法环境和变量环境</h3><ul><li><code>变量环境（variable environment）</code>：用于记录 var，function 声明的绑定。</li><li><code>词法环境（lexical environment）</code>：用于记录其他声明的绑定（如 let、const、class 等）。</li></ul><p>而词法环境中又包含两个组成部分：</p><ul><li><code>环境记录(environment record)</code>：记录相应代码块的标识符绑定，可理解为代码块内变量、函数等都绑定于此，对应 ES3 中的 VO（变量对象）和 AO（活动对象）。</li><li><code>外部词法环境引用（outer environment）</code>：用于形成多个词法环境在逻辑上的嵌套结构，以实现可以访问外部词法环境变量的能力，对应 ES3 中的作用域链。</li></ul><p>环境记录包含了：</p><ul><li><code>声明式环境记录（Declarative Environment Record）</code>：定义直接将标识符绑定的元素，例如 let、const、class、module、import 等</li><li><code>对象式环境记录（Object Environment Record）</code>：用于记录与某些对象属性绑定的元素，例如 with 语句、var 声明和函数声明</li><li><code>全局环境记录（Global Environment Record）</code>：就是存放 globalThis 上的属性元素</li></ul><p>可以用如下代码大概解释是怎么回事：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span>;<span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">d, e</span>) </span>&#123;  <span class="hljs-keyword">var</span> f = <span class="hljs-number">10</span>;  <span class="hljs-keyword">return</span> f * d * e;&#125;c = test(a, b);</code></pre><p>简要地抽象成看得懂的结构的话，预解析阶段的全局环境内：</p><pre><code class="hljs dts">GlobalLexicalEnvironment = &#123;<span class="hljs-symbol">  LexicalEnvironment:</span> &#123;<span class="hljs-symbol">    OuterReference:</span> null,<span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<span class="hljs-symbol">      a:</span> <span class="hljs-params">&lt;uninitialized&gt;</span> ,<span class="hljs-symbol">      b:</span> <span class="hljs-params">&lt;uninitialized&gt;</span>,    &#125;,  &#125;,<span class="hljs-symbol">  VariableEnvironment:</span> &#123;<span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<span class="hljs-symbol">      test:</span> <span class="hljs-params">&lt;func reference&gt;</span>,<span class="hljs-symbol">      c:</span> undefined,    &#125;  &#125;&#125;</code></pre><p>执行到最后时的环境：</p><pre><code class="hljs yaml"><span class="hljs-string">GlobalLexicalEnvironment</span> <span class="hljs-string">=</span> &#123;  <span class="hljs-attr">LexicalEnvironment:</span> &#123;    <span class="hljs-attr">OuterReference:</span> <span class="hljs-literal">null</span>,    <span class="hljs-attr">EnvironmentRecord:</span> &#123;      <span class="hljs-attr">a:</span> <span class="hljs-number">1</span> ,      <span class="hljs-attr">b:</span> <span class="hljs-number">2</span> ,    &#125;,  &#125;,  <span class="hljs-attr">VariableEnvironment:</span> &#123;    <span class="hljs-attr">EnvironmentRecord:</span> &#123;      <span class="hljs-attr">test:</span> <span class="hljs-string">&lt;func</span> <span class="hljs-string">reference&gt;</span>,      <span class="hljs-attr">c:</span> <span class="hljs-number">20</span>,    &#125;  &#125;&#125;<span class="hljs-string">FunctionLexicalEnvironment</span> <span class="hljs-string">=</span> &#123;,  <span class="hljs-attr">LexicalEnvironment:</span> &#123;    <span class="hljs-attr">OuterReference:</span>  <span class="hljs-string">&lt;GlobalLexicalEnvironment&gt;</span>,    <span class="hljs-attr">EnvironmentRecord:</span> &#123;      <span class="hljs-attr">arguments:</span> &#123;<span class="hljs-attr">0:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">1:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">length:</span> <span class="hljs-number">2</span>&#125;,    &#125;,  &#125;,  <span class="hljs-attr">VariableEnvironment:</span> &#123;    <span class="hljs-attr">EnvironmentRecord:</span> &#123;      <span class="hljs-string">f:10</span>,    &#125;  &#125;&#125;</code></pre><h3 id="为什么要有两个环境"><a href="#为什么要有两个环境" class="headerlink" title="为什么要有两个环境"></a>为什么要有两个环境</h3><p>主要是为了<code>实现块级作用域的同时不影响var声明和函数声明</code>。因为在 ES6 之前并没有块级作用域的概念，而 ES6 后又可以使用 let 和 const 实现，那这时候就需要不影响 var 声明和函数声明了。</p><p>原理是当正在执行的上下文，运行到块级代码时：</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 输出：undefined</span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);  &#125;&#125;<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 输出: ƒ foo() &#123;console.log(&#x27;hello&#x27;)&#125;</span></code></pre><p>会将此时的词法环境记录下来，并且在块级内部创建新的词法环境，然后将外部词法环境指向上一层被记录的词法环境中。然后块级中的 let 和 const 都会被记录到当前的词法环境，而 var 和函数声明就还是绑定在变量环境上了。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域指的源代码中定义变量的区域，它规定了执行代码对变量的访问权限。而常见的作用域有<code>词法作用域（lexical scope）</code>和<code>动态作用域（dynamic scope）</code>。而 Javascript 使用的是词法作用域，也就是说无论函数在哪里被调用，也无论它如何被调用，它的作用域都只由函数被声明时所处的位置决定</p><h3 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h3><p>词法作用域即定义时就决定作用域了，而动态作用域即在执行调用时才能确定作用域。</p><p>在《JavaScript 权威指南》中的例子就是个典型的作用域问题：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;global scope&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;local scope&#x27;</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> scope;  &#125;  <span class="hljs-keyword">return</span> f();&#125;checkscope();<span class="hljs-comment">// local scope</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;global scope&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;local scope&#x27;</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> scope;  &#125;  <span class="hljs-keyword">return</span> f;&#125;checkscope()();<span class="hljs-comment">// local scope</span></code></pre><p>上述两个例子执行结果都会返回 <code>local scope</code>，因为 JavaScript 采用词法作用域，而函数 <code>f</code> 在 <code>checkscope</code> 内部被定义，所以此时已经确定了他所在的作用域了。</p><p>可能会好奇什么是动态作用域，可以将如下代码保存，并 bash 执行，因为 bash 是动态作用域：</p><pre><code class="hljs bash">c=1;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">func1</span></span> () &#123;  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$c</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">func2</span></span>() &#123;  <span class="hljs-built_in">local</span> c=2;  func1;&#125;func2</code></pre><p>这里会输出 2，而在 JavaScript 中会打印 1：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(c);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> c = <span class="hljs-number">2</span>;  func1();&#125;func2();</code></pre><p>这里就是体现词法作用域和动态作用域的区别。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在计算机术语中，函数体作用域内包含了其变量环境，这个函数就是闭包（clourse），通俗点就是拥有<code>自由变量</code>并处在这些<code>自由变量</code>外部且能访问到外部的这些<code>自由变量</code>的函数。</p><p>很拗口是吧？其实严格意义上 JavaScript 中<code>所有函数都是闭包</code>。为了实现词法作用域，JavaScript 函数对象的内部状态不仅包含逻辑代码，还包含了当前作用域链的引用。</p><p>就很简单的例子：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(a);&#125;func();</code></pre><p>func 方法内拥有不属于自身变量环境的自由变量 a，那么 func 就是闭包。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>301、302、303、307、308</title>
    <link href="/301%E3%80%81302%E3%80%81303%E3%80%81307%E3%80%81308/"/>
    <url>/301%E3%80%81302%E3%80%81303%E3%80%81307%E3%80%81308/</url>
    
    <content type="html"><![CDATA[<h1 id="301、302、303、307、308"><a href="#301、302、303、307、308" class="headerlink" title="301、302、303、307、308"></a>301、302、303、307、308</h1><h2 id="1、HTTP-状态码"><a href="#1、HTTP-状态码" class="headerlink" title="1、HTTP 状态码"></a>1、HTTP 状态码</h2><p>HTTP 状态码是由 RFC2616 规范定义的，用以表示服务器超文本传输协议响应状态的 3 位数字代码。状态码是协助开发者掌握请求是否运转正常的一个标志，常见的大概有 200，304，404，500 等。每个状态码都有其代表的意义，而且也发挥着不同的作用。</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/status-code-1.jpeg" alt="有趣的状态码1"></p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/status-code-2.jpeg" alt="有趣的状态码2"></p><h2 id="2、HTTP-3xx"><a href="#2、HTTP-3xx" class="headerlink" title="2、HTTP 3xx"></a>2、HTTP 3xx</h2><p>HTTP 状态码 3xx 一类的都是重定向（Redirect），需要进一步的操作以完成请求。</p><p><em>参考<a href="https://tools.ietf.org/html/rfc7231#section-6.4">RFC7231 第六节</a></em></p><table><thead><tr><th>状态码</th><th>状态码名称</th><th>描述</th></tr></thead><tbody><tr><td>300</td><td>Mutiple Choices</td><td>表示目标资源具有多种选择，用户或浏览器能够自行选择一个首选的地址进行重定向。</td></tr><tr><td>301</td><td>Moved Permanently</td><td>资源已被永久移动到新位置，服务器应生成一个 Location 字段，让用户代理可以使用此字段进行自动重定向。由于历史原因，用户代理可能会改变请求方法</td></tr><tr><td>302</td><td>Found</td><td>表示目标资源暂时驻留在其他 URI 下，由于重定向可能随时被更改，所以客户端应该继续使用有效请求。服务器应生成一个 Location 字段，让用户代理可以使用此字段进行自动重定向。由于历史原因，用户代理可能会改变请求方法</td></tr><tr><td>303</td><td>See Other</td><td>表示服务器需要将用户代理重定向至另一个资源，客户端会将请求方法改为 GET。与 302 类似，因为历史原因增加的状态码。大部分 HTTP/1.1 版以前的浏览器不能理解 303 状态。</td></tr><tr><td>304</td><td>Not Modified</td><td>表示客户端发送了一个带条件的 GET 或 HEAD 请求并且被允许，而且内容还是有效（自上次访问后根据请求的条件），则服务器应当返回这个状态码，并且禁止包含消息体</td></tr><tr><td>305</td><td>Use Proxy</td><td>表示被请求资源需要通过制定代理才能被访问，现已被弃用</td></tr><tr><td>306</td><td>Switch Proxy</td><td>已被弃用，但是保留状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>表示资源暂时被重定向到不同的位置，因为重定向随时会被改变，所以客户端应继续使用原始的有效请求。与 302 类似，只是不允许将请求方法从 POST 改为 GET</td></tr><tr><td>308</td><td>Permanent Redirect</td><td>这个跟 301 差不多，只是不允许将请求方法从 POST 改为 GET（<a href="https://tools.ietf.org/html/rfc7238#section-3">RFC7238</a>）</td></tr></tbody></table><h2 id="3、各大网站的重定向"><a href="#3、各大网站的重定向" class="headerlink" title="3、各大网站的重定向"></a>3、各大网站的重定向</h2><p>在日常浏览网页的时候，如果有心观察请求，有时候会发现一些页面返回的是 301 或者 302。</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/status-code-engadget.png" alt="engadaget"></p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/status-code-google.png" alt="google"></p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/status-code-jd.png" alt="jd"></p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/status-code-xiaomi.png" alt="xiaomi"></p><p>还能看到一些 307 的：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/status-code-taobao.png" alt="taobao"></p><p>(讲道理淘宝前几天还是 302)</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/status-code-youtube.png" alt="youtube"></p><h2 id="4、实际应用场景"><a href="#4、实际应用场景" class="headerlink" title="4、实际应用场景"></a>4、实际应用场景</h2><p>上面了解到了部分 3xx 状态码的意义，但是还是不知道是用来做什么的。其实 301 和 302 看起来效果是一样的，对于浏览器来说都会去重新对 Location 字段请求。这个过程可以称之为重定向，表现为用户在地址栏输入的地址 A，瞬间变成了地址 B。</p><h3 id="4-1、为什么需要重定向"><a href="#4-1、为什么需要重定向" class="headerlink" title="4-1、为什么需要重定向"></a>4-1、为什么需要重定向</h3><p>正常来说，浏览网站就浏览了，为什么需要重定向到另一个地址呢？一般来说分为以下几种情况：</p><ul><li>网站域名更改（例如 xiaomi.com 变成 mi.com）</li><li>网站路径更改（例如页面路径更改，扩展名更改等）</li><li>网站协议更改（例如 http 的页面需要跳到 https）</li><li>多个域名，需要将流量和权重综合到主站上</li></ul><p>以上几种情况可以总结为，就是地址更改了，但是原地址都需要跳转到新地址上。如果没有重定向，用户的历史记录或者收藏夹或者搜索引擎的数据库中都只会得到一个 404 错误页面，让访问量白白流失，或者是某些注册了多个域名的网站，需要通过重定向让用户自动跳转到主站点。这时候就都需要用到重定向了。</p><h3 id="4-2、关于-PR"><a href="#4-2、关于-PR" class="headerlink" title="4-2、关于 PR"></a>4-2、关于 PR</h3><p>对于普通浏览，其实 301 和 302 看起来是一样的，但是对于搜索引擎来说就完全不一样了，在此之前要科普一个名词叫<strong>PR</strong>。</p><p><a href="https://zh.wikipedia.org/wiki/PageRank">PR</a>全称为 PageRank，级别是 0 到 10，是一个用以评测网页等级和重要性的一个指标。简单来说，PR 值越高，网页越受欢迎，或者说越重要，但是根据 Google 官方所说，PR 并不能对网站排名产生绝对作用。但是高 PR 值会被：</p><ul><li>收录更多的页面</li><li>搜索引擎 spider 会访问更频繁，新内容更快被收录</li><li>重复内容会更容易被判断为原创</li><li>排名进入初始子集几率更大</li></ul><h3 id="4-3、301-和-302"><a href="#4-3、301-和-302" class="headerlink" title="4-3、301 和 302"></a>4-3、301 和 302</h3><p>301 含义是<strong>永久性重定向</strong>，302 是<strong>暂时性重定向</strong>，这样看起来好像用 302 就可以了，但是无论是 <a href="https://developers.google.com/search/docs/advanced/crawling/301-redirects?visit_id=637419026366730396-2964136309&rd=1">Google</a> 还是<a href="https://developer.baidu.com/resources/online/doc/seo/search-engine-optimization-guide.html#%E5%90%88%E7%90%86%E7%9A%84%E8%BF%94%E5%9B%9E%E7%A0%81">百度</a>都建议用 301。那到底是有什么区别呢？</p><p>假如现在有两个页面分别是 A（xxx.com）和B（h5.xxxxx.com），而我们需要告诉搜索引擎B页面就是原来的A页面，这时候就需要重定向方式处理。</p><ul><li>返回 301：如果 A 页面原来就已经被搜索引擎收录了，那么当搜索引擎再次爬取到 A 页面时，因为获取到 301，这样就会知道以后再也没有 A 页面，搜索引擎会将原本 A 页面的排名权重（PR 值）转移到 B 页面上去，并且将数据库中 A 页面记录替换成 B 页面。</li><li>返回 302：搜索引擎会觉得这次只是临时跳转，未来 A 页面随时可能改变跳转，重新显示原来内容或者跳转到其他地方，所以搜索引擎接收到 302 时，数据库并不会删除 A 页面，而是新建 B 页面的记录，A 页面的 PR 值也不会转移到 B 页面上去。</li></ul><p>为什么建议用 301，一方面是 PR 的浪费问题，另一方面是 URL 劫持的问题。</p><p>实际上如果搜索引擎接收到 302 跳转时，永远都去抓取 Location 目标的话，就不会有这种问题了，正正是因为搜索引擎尤其是 Google，并不能总是有效抓取 Location，这是因为 Google 有自己的考虑在里面：当 B 页面的 URL 是个杂乱且冗长带各种参数的网址，而 A 页面却是简短且友好的话，Google 很有可能还是显示 A 网址。而这时候，一些人就会利用这一点，让自己的 C 页面返回 302 指向一个 内容质量较高的 D 页面，然后因为 Google 的这套机制，可能显示的搜索结果还是 C 但是内容却是 D 页面的内容了，这样子 D 页面的作者的辛苦写的东西都被窃取者偷走并作为自己的成果。这个就是 URL 劫持。</p><p>虽然 Google 对 302 问题很重视，URL 劫持现象还是有点改善，但是没有完全解决。而如果长时间用 302 作为长期跳转，搜索引擎会判定这个行为是作弊行为，302 也很容易被搜索引擎误认为是利用多个域名指向同一站点，会对页面给予惩罚，甚至封掉，挂上“利用重复内容干扰 Google 搜索结果的网站排名”。所以在使用网站重定向时，非必要不建议用 302。</p><h3 id="4-4、不使用跳转的后果"><a href="#4-4、不使用跳转的后果" class="headerlink" title="4-4、不使用跳转的后果"></a>4-4、不使用跳转的后果</h3><p>一方面是搜索引擎会发现有新页 B 面进行收录，但是由于没有跳转，所以认为是个全新的页面，与原来的 A 网站无关联，所以 A 的页面 PR 不会传到给 B，如果原来 A 的 PR 值很高，B 页面却需要重新计算，这里就会很吃亏</p><p>另一方面则是如果搜索引擎访问 A 页面，由于没跳转发现的是 404 表示资源找不到，搜索引擎会认为网站没做好并且会给予惩罚，导致排名下降</p><h2 id="5、-PR-劫持"><a href="#5、-PR-劫持" class="headerlink" title="5、 PR 劫持"></a>5、 PR 劫持</h2><p>大概原理其实是利用了 301 或 302 跳转，把自己的网站 A 重定向至高 PR 值网站 B，因为 B 网站的 PR 值较高，在 A 网站 PR 值更新后，也会显示成 B 网站的 PR 值。利用这点，A 网站得到了本不属于自己的高 PR，并且在更新了 PR 后，立刻取消重定向，放上自己的内容。这样做，就会让浏览者误以为这个网站是个高 PR 值的网站。而本次 PR 劫持至少能持续到下一次 PR 值更新，大概会有 2~3 个月。</p><p>更隐晦一点的做法是，通过请求检测到本次为搜索引擎的 spider 时，返回 301 指向高 PR 值网站，却对普通浏览者返回原本页面，这样子做，甚至可以不影响自己的内容的前提下劫持了高 PR 值的网站。</p><h2 id="6、那-303、307、308-是怎么回事"><a href="#6、那-303、307、308-是怎么回事" class="headerlink" title="6、那 303、307、308 是怎么回事"></a>6、那 303、307、308 是怎么回事</h2><p>通过上面的介绍可以知道，重定向的意义和对 seo 的影响，然后会发现 303、307、308 似乎跟 301 和 302 也差不多，但是又有所不同，然后网页的重定向返回码也各有不同，其实可以做个归类：</p><table><thead><tr><th></th><th>永久性重定向</th><th>暂时性重定向</th></tr></thead><tbody><tr><td>允许更改请求方法</td><td>301</td><td>302、303</td></tr><tr><td>不允许更改请求方法</td><td>308</td><td>307</td></tr></tbody></table><h3 id="6-1、302-和-303-和-307"><a href="#6-1、302-和-303-和-307" class="headerlink" title="6-1、302 和 303 和 307"></a>6-1、302 和 303 和 307</h3><p>其实 303 可以理解为 302 的规范化版本，307 则是原本的 302 规范。在最初的 302 定义中，内容与现在的 307 意义，不允许重定向方法改写，但是早期的浏览器实现的时候，有些实现成现在的 303（允许更改请求方法），有些实现成现在的 307（不允许更改请求方法），于是乎之后的标准，就将 302 某些错误的实现写入规范成为了 303，而 302 原本的规范复制到了 307。在最近的一次修订中，302 标准不再强制需要维持原来请求方法，所以产生了现在的 302、303 和 307。</p><p>可<a href="https://tools.ietf.org/html/rfc7231#section-6.4.3">参阅 RFC7231</a>:（中间这个<strong>MAY</strong>很关键，在 307 规范中为 <strong>MUST NOT</strong>）<br><code>Note: For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent request. If this behavior is undesired, the 307 (Temporary Redirect) status code can be used instead.</code></p><h3 id="6-2、301-和-308"><a href="#6-2、301-和-308" class="headerlink" title="6-2、301 和 308"></a>6-2、301 和 308</h3><p>和 302 一样，301 在浏览器实现和标准有不一致问题，一直延续到了 2014 年的 RFC7231，所以后面标准补充了 308.</p><p>可<a href="https://tools.ietf.org/html/rfc7231#section-6.4.2">参阅 RFC7231</a>：（也是<strong>MAY</strong>，表明协议也妥协了实现）<br><code> Note: For historical reasons, a user agent MAY change the request method from POST to GET for the subsequent request. If this behavior is undesired, the 307 (Temporary Redirect) status code can be used instead.</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不准确的定时器</title>
    <link href="/%E4%B8%8D%E5%87%86%E7%A1%AE%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <url>/%E4%B8%8D%E5%87%86%E7%A1%AE%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="不准确的定时器"><a href="#不准确的定时器" class="headerlink" title="不准确的定时器"></a>不准确的定时器</h1><h3 id="什么是定时器"><a href="#什么是定时器" class="headerlink" title="什么是定时器"></a>什么是定时器</h3><p>javascript 的 globalThis 中，分别有三个 api：<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>，他们都是定时器的一种，意思是允许在某个时刻开始执行，尽管他们看上去很相似，不过其实各不相同，甚至在不同运行环境也各自不同。</p><ul><li>setTimeout：用于设置一个定时器，在到期后执行一个函数。</li><li>setInterval：用于设置一个轮训定时器，重复调用一个函数并在每次调用之间具有固定间隔。</li><li>setImmediate：用于设置一个立刻执行器，在当前事件轮询中任何 i/o 操作后，在任何下一轮定时器开始前执行。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li>setTimeout 和 setInterval 语法相当</li></ul><pre><code class="hljs javascript">var timeoutID = setTimeout(function[, delay, arg1, arg2, ...]);<span class="hljs-keyword">var</span> timeoutID = <span class="hljs-built_in">setTimeout</span>(code[, delay, arg1, arg2, ...]);var intervalID = setInterval(function[, delay, arg1, arg2, ...]);<span class="hljs-keyword">var</span> intervalID = <span class="hljs-built_in">setInterval</span>(code[, delay, arg1, arg2, ...]);</code></pre><p>第一个参数为回调函数，在 <code>WindowOrWorkerGlobalScope</code>下可以为<strong>脚本字符串</strong>（node 中不支持），如果为字符串则会被类似 eval()调用，非常不推荐。<br>第二个参数为<code>可选</code>的延迟毫秒数（1 秒为 1000 毫秒），如果省略该参数则默认为 0。<br>第三个往后的参数为<code>可选</code>的附加参数，会被作为参数传入 function 中。</p><ul><li>setImmidate 语法</li></ul><pre><code class="hljs javascript">var immediateID = setImmediate(function[, arg1, arg2, ...]);</code></pre><p>这里除了没延迟毫秒数外与 setTimeout 和 setInterval 差不多。此 api 在浏览器环境为非标准 api，尽量不在浏览器环境中使用。该 api 受到了 Gecko 和 Webkit 的阻力，可能未来也不会被纳入标准中。</p><p>可以通过 <code>MessageChannel</code> 或者 <code>postMessage</code> 来模拟一个 setImmediate。<strong>本篇文章不着重讲此 api</strong>。</p><h3 id="不准确是怎么回事"><a href="#不准确是怎么回事" class="headerlink" title="不准确是怎么回事"></a>不准确是怎么回事</h3><p>有很多因素会导致定时器的回调函数执行比设定的预期值更久，下面会分别讲解：</p><h4 id="最小间隔-4ms"><a href="#最小间隔-4ms" class="headerlink" title="最小间隔 4ms"></a>最小间隔 4ms</h4><p>在 HTML5 规范中，setTimeout 和 setInterval 被设定为最小间隔为 <code>4ms</code>（在<a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers">HTML5 spec</a>中被精确），这种通常是因为被函数阻塞或者函数嵌套级别到了一定深度导致的。例如：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span>(<span class="hljs-params"></span>) </span>&#123;  f();  <span class="hljs-built_in">setTimeout</span>(cb, <span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">setTimeout</span>(cb, <span class="hljs-number">0</span>);<span class="hljs-comment">// 或</span><span class="hljs-built_in">setInterval</span>(f, <span class="hljs-number">0</span>);</code></pre><p>在 Chrome 和 Firefox 中，定时器的第五次会被阻塞，Safari 是第六次，Edge 在第三次。</p><p>而最小延时，由<code>DOM_MIN_TIMEOUT_VALUE</code>（Firefox 在<code>dom.min_timeout_value</code>）这个变量控制，而 node 为了与浏览器行为对齐，设置了最低<a href="https://github.com/nodejs/node/blob/v8.9.4/lib/timers.js#L456">1ms 的间隔</a>。</p><p>所以如果测试一下 setTimeout 递归 60 次（模拟 60 秒），电脑为 MacBook Pro (13-inch, 2019, Four Thunderbolt 3 ports)：</p><pre><code class="hljs javascript">(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">let</span> n2 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> tick2 = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      n2++;      <span class="hljs-keyword">if</span> (n2 === <span class="hljs-number">60</span>) &#123;        <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        tick2();      &#125;    &#125;, <span class="hljs-number">1000</span>);  &#125;;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);  tick2();&#125;)();</code></pre><p>在<code>chrome85</code>中时间为：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/setTimeout-screenshot.png" alt="测试结果"></p><p>总共是有 155ms 的延迟。</p><p>在<code>node v12.18.3</code>中时间为：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/setTimeout-node-screenshot.png" alt="测试结果"></p><p>总共是有 163ms 的延迟。</p><h4 id="未被激的会话窗最小延迟-1000ms"><a href="#未被激的会话窗最小延迟-1000ms" class="headerlink" title="未被激的会话窗最小延迟 1000ms"></a>未被激的会话窗最小延迟 1000ms</h4><p>这是浏览器为了优化后台 tab 的加载损耗（或者说降低耗电量），对不在前台的会话窗最小延迟限制为 1000ms</p><p>我们可以继续测试一下上面的代码，全程把页面放入后台中，在<code>chrome85</code>中时间为：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/setTimeout-background-screenshot.png" alt="测试结果"></p><p>总共是有 39396ms(39s) 的延迟。</p><h4 id="最大间隔为-2147483647ms"><a href="#最大间隔为-2147483647ms" class="headerlink" title="最大间隔为 2147483647ms"></a>最大间隔为 2147483647ms</h4><p>这个就不测试了，很简单就是 <code>2^31 - 1</code>毫秒，因为浏览器内部以 32 位整数存储延时，这样会导致定时器立刻执行。</p><h3 id="解决延迟"><a href="#解决延迟" class="headerlink" title="解决延迟"></a>解决延迟</h3><p><strong>讲道理这个很难</strong>，因为作为一个单线程语言，可能会在任何时间内被阻塞，按道理无法保证其时间准确性。</p><h4 id="requestTimeout"><a href="#requestTimeout" class="headerlink" title="requestTimeout"></a>requestTimeout</h4><p>但是可以用一些自动或者动态修正的方法去减少误差，我们可以先实现一个 requestTimeout，先做个流程图</p><pre><code class="hljs mermaid">graph TB    start[设置定时器] --传入回调函数和间隔时间--&gt; 记录当前时间戳    记录当前时间戳 --&gt; 计算出目标时间戳    计算出目标时间戳 --&gt; 计算出剩余间隔时间&#123;计算出剩余间隔时间&#125;    计算出剩余间隔时间&#123;计算出剩余间隔时间&#125; --大于边界时间--&gt; 切分剩余时间    计算出剩余间隔时间&#123;计算出剩余间隔时间&#125; --小于边界时间--&gt; 按剩余间隔时间延迟执行    切分剩余时间 --&gt; 用切分出的时间延迟执行    用切分出的时间延迟执行 --&gt; 记录当前时间戳    按剩余间隔时间延迟执行 --&gt; 结束</code></pre><p>这样其实也只能将间隔时间缩得足够小，每一次切分其实都是重新拿时间戳去对照了。</p><p>代码实现：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; requestTimeout, cancelTimeout &#125; = (<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 建立的任务表</span>  <span class="hljs-keyword">const</span> cacheMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-comment">// 获取当前相对时间戳</span>  <span class="hljs-keyword">const</span> getNow =    <span class="hljs-keyword">typeof</span> process !== <span class="hljs-string">&#x27;undefined&#x27;</span>      ? <span class="hljs-function">() =&gt;</span> process.uptime() * <span class="hljs-number">1000</span>      : <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> Event(<span class="hljs-string">&#x27;&#x27;</span>).timeStamp;  <span class="hljs-keyword">const</span> RATIO = <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 拆解timer时间系数</span>  <span class="hljs-keyword">const</span> EDGE = <span class="hljs-number">10</span>; <span class="hljs-comment">// 边界值</span>  <span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 请求延迟回调</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>fn 回调函数</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>delay 延迟时间</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>isBlock 是否使用阻塞</span><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">id</span></span></span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">const</span> requestTimeout = <span class="hljs-function">(<span class="hljs-params">fn, delay = <span class="hljs-number">0</span>, isBlock = <span class="hljs-literal">false</span></span>) =&gt;</span> &#123;    id++;    cacheMap.set(id, &#123; <span class="hljs-attr">pause</span>: <span class="hljs-literal">false</span> &#125;);    <span class="hljs-comment">// 获取是否允许继续</span>    <span class="hljs-keyword">const</span> getAllowContinue = <span class="hljs-function">() =&gt;</span> !cacheMap.get(id).pause;    <span class="hljs-comment">// 上一次调度器执行的时间戳</span>    <span class="hljs-keyword">let</span> previousTimeStamp = getNow();    <span class="hljs-comment">// 目标时间戳</span>    <span class="hljs-keyword">const</span> targetTimestamp = previousTimeStamp + delay;    <span class="hljs-comment">// 调度器</span>    <span class="hljs-keyword">const</span> requestScheduler = isBlock      ? <span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (getAllowContinue()) &#123;            <span class="hljs-comment">// 阻塞</span>            <span class="hljs-keyword">while</span> (              getNow() - previousTimeStamp &lt; delay &amp;&amp;              getAllowContinue()            ) &#123;&#125;            fn();          &#125;        &#125;      : <span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (getAllowContinue()) &#123;            previousTimeStamp = getNow();            <span class="hljs-comment">// 获取剩余延迟时间</span>            <span class="hljs-keyword">const</span> restDelay = targetTimestamp - previousTimeStamp;            <span class="hljs-comment">// 判断是否剩余小于边界值的时间</span>            <span class="hljs-keyword">const</span> nearTheEdge = restDelay &lt;= EDGE;            <span class="hljs-built_in">setTimeout</span>(              () =&gt; &#123;                nearTheEdge ? fn() : requestScheduler();              &#125;,              nearTheEdge ? restDelay : restDelay * RATIO            );          &#125;        &#125;;    requestScheduler();    <span class="hljs-keyword">return</span> id;  &#125;;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 取消延迟任务</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>id 任务id</span><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">const</span> cancelTimeout = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (cacheMap.has(id)) &#123;      <span class="hljs-keyword">const</span> cache = cacheMap.get(id);      cache.pause = <span class="hljs-literal">true</span>;    &#125;  &#125;;  <span class="hljs-keyword">return</span> &#123;    requestTimeout,    cancelTimeout,  &#125;;&#125;)();</code></pre><p>这里实际上还用了阻塞去做延迟执行，这样子更精准点但是会阻塞线程。</p><p>下面可以测试一下执行精度：</p><ul><li><p>浏览器前台：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/requestTimeout-screenshot.png" alt="测试结果"></p></li><li><p>浏览器后台：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/requestTimeout-background-screenshot.png" alt="测试结果"></p></li><li><p>node：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/requestTimeout-node-screenshot.png" alt="测试结果"></p></li></ul><p>requestTimeout 在后台递归的时候表现更差了，这是因为本身就被浏览器延迟了，但是单次执行的准确度还是比 setTimeout 高的。</p><ul><li><p>setTimeout 单次：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/setTimeout.png" alt="测试结果"></p></li><li><p>requestTimeout 单次：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/requestTimeout.png" alt="测试结果"></p></li></ul><h4 id="requestInterval"><a href="#requestInterval" class="headerlink" title="requestInterval"></a>requestInterval</h4><p>interval 倒是完全可以减少误差的，办法就是每次都获取上一次的真实间隔时间，然后再动态更改下一次的延迟即可。根据这个想法做个流程图：</p><pre><code class="hljs mermaid">graph TB    start[设置定时器] --传入回调函数和间隔时间--&gt; 记录当前时间戳    记录当前时间戳 --&gt; 调度器执行    调度器执行 --&gt; 获取执行时时间戳    获取执行时时间戳 --&gt; 计算出差值并计算出下次间隔时间    计算出差值并计算出下次间隔时间 --&gt; 按新的间隔时间延迟执行    按新的间隔时间延迟执行 --&gt; 将执行时间戳替换了上次时间戳    将执行时间戳替换了上次时间戳 --&gt; 记录当前时间戳</code></pre><p>延迟执行可以利用上面实现的 requestTimeout，按流程图实现代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; requestInterval, cancelInterval &#125; = (<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 建立的任务表</span>  <span class="hljs-keyword">const</span> cacheMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-comment">// 获取当前相对时间戳</span>  <span class="hljs-keyword">const</span> getNow =    <span class="hljs-keyword">typeof</span> process !== <span class="hljs-string">&#x27;undefined&#x27;</span>      ? <span class="hljs-function">() =&gt;</span> process.uptime() * <span class="hljs-number">1000</span>      : <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> Event(<span class="hljs-string">&#x27;&#x27;</span>).timeStamp;  <span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 请求间隔调用</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>fn 回调函数</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>interval 间隔时间</span><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">id</span></span></span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">const</span> requestInterval = <span class="hljs-function">(<span class="hljs-params">fn, interval = <span class="hljs-number">0</span></span>) =&gt;</span> &#123;    id++;    cacheMap.set(id, &#123; <span class="hljs-attr">pause</span>: <span class="hljs-literal">false</span> &#125;);    <span class="hljs-comment">// 上一调度器执行时间戳</span>    <span class="hljs-keyword">let</span> previousTimeStamp = getNow();    <span class="hljs-comment">// 获取是否允许继续</span>    <span class="hljs-keyword">const</span> getAllowContinue = <span class="hljs-function">() =&gt;</span> !cacheMap.get(id).pause;    <span class="hljs-comment">// 调度器</span>    <span class="hljs-keyword">const</span> requestScheduler = <span class="hljs-function">(<span class="hljs-params">currentInterval = interval</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (getAllowContinue()) &#123;        requestTimeout(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">const</span> currentTimeStamp = getNow(); <span class="hljs-comment">// 当前时间戳</span>          <span class="hljs-keyword">const</span> realInterval = currentTimeStamp - previousTimeStamp; <span class="hljs-comment">// 本次和上次的真实间隔</span>          <span class="hljs-keyword">const</span> delta = interval + (interval - realInterval); <span class="hljs-comment">// 间隔差值</span>          <span class="hljs-keyword">const</span> nextInterval = delta &gt; <span class="hljs-number">0</span> ? delta : <span class="hljs-number">0</span>; <span class="hljs-comment">// 下一次间隔时间</span>          <span class="hljs-keyword">const</span> skipTimes = <span class="hljs-built_in">Math</span>.floor((realInterval - interval) / interval); <span class="hljs-comment">// 被跳过的次数（被阻塞或者睡眠）</span>          previousTimeStamp = currentTimeStamp;          fn(skipTimes &gt; <span class="hljs-number">0</span> ? skipTimes : <span class="hljs-number">0</span>);          requestScheduler(nextInterval);        &#125;, currentInterval);      &#125;    &#125;;    requestScheduler();    <span class="hljs-keyword">return</span> id;  &#125;;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 取消间隔任务</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>id 任务id</span><span class="hljs-comment">   * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;void&#125;</span></span></span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">const</span> cancelInterval = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (cacheMap.has(id)) &#123;      <span class="hljs-keyword">const</span> cache = cacheMap.get(id);      cache.pause = <span class="hljs-literal">true</span>;    &#125;  &#125;;  <span class="hljs-keyword">return</span> &#123;    requestInterval,    cancelInterval,  &#125;;&#125;)();</code></pre><h3 id="测试结果对比"><a href="#测试结果对比" class="headerlink" title="测试结果对比"></a>测试结果对比</h3><p>测试代码为</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 60次requestTimeout递归测试</span><span class="hljs-comment"> */</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">let</span> n1 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> tick1 = <span class="hljs-function">() =&gt;</span> &#123;    requestTimeout(<span class="hljs-function">() =&gt;</span> &#123;      n1++;      <span class="hljs-keyword">if</span> (n1 &gt;= <span class="hljs-number">60</span>) &#123;        <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;60 times requestTimeout&#x27;</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        tick1();      &#125;    &#125;, <span class="hljs-number">1000</span>);  &#125;;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;60 times requestTimeout&#x27;</span>);  tick1();&#125;)();<span class="hljs-comment">/**</span><span class="hljs-comment"> * setTimeout测试对照组</span><span class="hljs-comment"> */</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">let</span> n2 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> tick2 = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      n2++;      <span class="hljs-keyword">if</span> (n2 === <span class="hljs-number">60</span>) &#123;        <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        tick2();      &#125;    &#125;, <span class="hljs-number">1000</span>);  &#125;;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);  tick2();&#125;)();<span class="hljs-comment">/**</span><span class="hljs-comment"> * setInterval测试对照组</span><span class="hljs-comment"> */</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;setInterval&#x27;</span>);  <span class="hljs-keyword">let</span> n3 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> timer1 = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;    n3++;    <span class="hljs-keyword">if</span> (n3 === <span class="hljs-number">60</span>) &#123;      <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;setInterval&#x27;</span>);      <span class="hljs-built_in">clearInterval</span>(timer1);    &#125;  &#125;, <span class="hljs-number">1000</span>);&#125;)();<span class="hljs-comment">/**</span><span class="hljs-comment"> * requestInterval测试对照组1</span><span class="hljs-comment"> */</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;requestInterval1&#x27;</span>);  <span class="hljs-keyword">let</span> n4 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> timer2 = requestInterval(<span class="hljs-function">() =&gt;</span> &#123;    n4++;    <span class="hljs-keyword">if</span> (n4 === <span class="hljs-number">60</span>) &#123;      <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;requestInterval1&#x27;</span>);      cancelInterval(timer2);    &#125;  &#125;, <span class="hljs-number">1000</span>);&#125;)();<span class="hljs-comment">/**</span><span class="hljs-comment"> * requestInterval测试对照组2</span><span class="hljs-comment"> */</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;requestInterval2&#x27;</span>);  <span class="hljs-keyword">let</span> n5 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> timer3 = requestInterval(<span class="hljs-function">() =&gt;</span> &#123;    n5++;    <span class="hljs-keyword">if</span> (n5 === <span class="hljs-number">60</span>) &#123;      <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;requestInterval2&#x27;</span>);      cancelInterval(timer3);    &#125;  &#125;, <span class="hljs-number">1000</span>);&#125;)();<span class="hljs-comment">/**</span><span class="hljs-comment"> * requestInterval测试对照组3</span><span class="hljs-comment"> */</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;requestInterval3&#x27;</span>);  <span class="hljs-keyword">let</span> n6 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> timer4 = requestInterval(<span class="hljs-function">() =&gt;</span> &#123;    n6++;    <span class="hljs-keyword">if</span> (n6 === <span class="hljs-number">60</span>) &#123;      <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;requestInterval3&#x27;</span>);      cancelInterval(timer4);    &#125;  &#125;, <span class="hljs-number">1000</span>);&#125;)();</code></pre><ul><li><p>浏览器前台：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/requestInterval-screenshot.png" alt="测试结果"></p></li><li><p>浏览器后台：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/requestInterval-background-screenshot.png" alt="测试结果"></p></li><li><p>node：</p><p><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/requestInterval-node-screenshot.png" alt="测试结果"></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，在 node 中表现会更好更准确，但是在浏览器后台的情况下就一般般了。但是最后还是记得要<code>清除定时器</code>以免发生内存泄露。</p><p>最后附上<a href="https://github.com/ben-lau/blog/blob/master/assets/script/requestTimer.js">完整代码</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2 响应式原理</title>
    <link href="/Vue2%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/Vue2%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue2-响应式原理"><a href="#Vue2-响应式原理" class="headerlink" title="Vue2 响应式原理"></a>Vue2 响应式原理</h1><p>当前笔记为<code>2.6.11</code>版本的 Vue</p><p>很多人对 Vue 的响应式原理大概能说得出，但是完整深入的流程可能不太清晰，其实中间还是有很多有趣的部分，下面将会从初始化开始讲起整个响应式系统的原理。部分代码片段中会有些个人理解所加的注解，注意留意一下。</p><h2 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h2><p>先从<a href="https://github.com/vuejs/vue/blob/v2.6.11/src/core/instance/index.js">vue/src/core/instance/index.js</a>进入，这里是 Vue 的构造函数，下面调用了<a href="https://github.com/vuejs/vue/blob/v2.6.11/src/core/instance/init.js">initMixin</a>，让我们进入去看看。</p><h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><p>这里会给 Vue 的 prototype 注入<code>\_init</code>方法，并且在实例化（<code>new Vue</code>）或创建组件（<code>Vue.extend</code>）时调用它。在这里，可以看到 Vue 在<code>beforeCreate</code>和<code>created</code> 的时机究竟做了什么，这里先只讨论响应式原理，所以我们看到<a href="https://github.com/vuejs/vue/blob/v2.6.11/src/core/instance/init.js#L57">initState</a>方法被调用，然后进入<a href="https://github.com/vuejs/vue/blob/v2.6.11/src/core/instance/state.js#L48">state.js</a></p><pre><code class="hljs javascript"><span class="hljs-comment">// 初始化state，这里初始化了props、methods、data、computed、watch</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initState</span>(<span class="hljs-params">vm: Component</span>) </span>&#123;  vm._watchers = [];  <span class="hljs-keyword">const</span> opts = vm.$options;  <span class="hljs-keyword">if</span> (opts.props) initProps(vm, opts.props); <span class="hljs-comment">// 初始化props</span>  <span class="hljs-keyword">if</span> (opts.methods) initMethods(vm, opts.methods); <span class="hljs-comment">// 初始化methods</span>  <span class="hljs-keyword">if</span> (opts.data) &#123;    initData(vm); <span class="hljs-comment">// 初始化data</span>  &#125; <span class="hljs-keyword">else</span> &#123;    observe((vm._data = &#123;&#125;), <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>); <span class="hljs-comment">// 如果没data则给_data赋空对象并映射给data</span>  &#125;  <span class="hljs-keyword">if</span> (opts.computed) initComputed(vm, opts.computed); <span class="hljs-comment">// 初始化computed</span>  <span class="hljs-comment">// nativeWatch判断是因为firefox里Object.prototype中有watch属性</span>  <span class="hljs-keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;    initWatch(vm, opts.watch); <span class="hljs-comment">// 初始化watch</span>  &#125;&#125;</code></pre><h3 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h3><p>下面就是如何去初始化 data 的 initData 函数</p><pre><code class="hljs javascript"><span class="hljs-comment">// 初始化data，这里要判断获取一次data和判断data是否与props和methods同名，然后要将data挂载到_data，并代理this.访问，然后观察属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initData</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;  <span class="hljs-keyword">let</span> data = vm.$options.data  data = vm._data = <span class="hljs-keyword">typeof</span> data === ‘<span class="hljs-function"><span class="hljs-keyword">function</span>’ // 将配置中的<span class="hljs-title">data</span>挂载到<span class="hljs-title">this</span>.<span class="hljs-title">_data</span></span><span class="hljs-function">    ? <span class="hljs-title">getData</span>(<span class="hljs-params">data, vm</span>) // 如果<span class="hljs-title">data</span>是个函数</span><span class="hljs-function">    : <span class="hljs-title">data</span> || </span>&#123;&#125;  <span class="hljs-keyword">if</span> (!isPlainObject(data)) &#123; <span class="hljs-comment">// 如果得出的data不是个对象就警告</span>    data = &#123;&#125;    process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; warn(      <span class="hljs-string">&#x27;data functions should return an object:\n&#x27;</span> +      <span class="hljs-string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,      vm    )  &#125;  <span class="hljs-comment">// proxy data on instance</span>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(data)  <span class="hljs-keyword">const</span> props = vm.$options.props  <span class="hljs-keyword">const</span> methods = vm.$options.methods  <span class="hljs-keyword">let</span> i = keys.length  <span class="hljs-keyword">while</span> (i--) &#123;    <span class="hljs-keyword">const</span> key = keys[i]    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;      <span class="hljs-keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;        warn(          <span class="hljs-string">`Method &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,          vm        )      &#125;    &#125;    <span class="hljs-keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;      process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; warn(        <span class="hljs-string">`The data property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +        <span class="hljs-string">`Use prop default value instead.`</span>,        vm      )    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isReserved(key)) &#123;      proxy(vm, <span class="hljs-string">`_data`</span>, key)  <span class="hljs-comment">// 代理this.属性访问指向this._data.属性内</span>    &#125;  &#125;  <span class="hljs-comment">// observe data</span>  observe(data, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)  <span class="hljs-comment">// 开始观察对象</span>&#125;<span class="hljs-comment">// 这方法是用来代理某个对象的属性访问指向到另一个对象上的</span><span class="hljs-comment">// 这里也是你能从this上直接获取到data内的属性的原理，其实是this.属性利用getter指向了this._data.属性上了，setter同理</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxy</span> (<span class="hljs-params">target: Object, sourceKey: string, key: string</span>) </span>&#123;  sharedPropertyDefinition.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyGetter</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[sourceKey][key]  &#125;  sharedPropertyDefinition.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxySetter</span> (<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-built_in">this</span>[sourceKey][key] = val  &#125;  <span class="hljs-built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)&#125;<span class="hljs-comment">// 获取方法型data时将null推入dep栈，不去触发data的getter依赖收集，后面会说为什么要用dep栈管理dep</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span> (<span class="hljs-params">data: Function, vm: Component</span>): <span class="hljs-title">any</span> </span>&#123;  <span class="hljs-comment">// #7573 disable dep collection when invoking data getters</span>  pushTarget() <span class="hljs-comment">// 空入栈</span>  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">return</span> data.call(vm, vm) <span class="hljs-comment">// 获取方法型data</span>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    handleError(e, vm, <span class="hljs-string">`data()`</span>)    <span class="hljs-keyword">return</span> &#123;&#125;  &#125; <span class="hljs-keyword">finally</span> &#123;    popTarget() <span class="hljs-comment">// 出栈</span>  &#125;&#125;</code></pre><p>这里从上往下做了几件事</p><ol><li>首先将配置中的 data 交给实例上的_data，如果是函数则执行，执行途中会将空推入 dep 栈中（后面会解释为什么要用栈），目的是防止 data 有已被观察的对象并触发了依赖收集，毕竟这里只是去一次 data 值。</li><li>判断如果配置 data 为非对象，或者对象内属性名与 props 和 methods 的字段名有冲突则报警告。</li><li>将_data 上的属性代理到实例对象内，即平时用的<code>this.属性</code>其实访问的是<code>this._data.属性</code>。</li><li>开始观察 data，并且加个 root 标志，意思是这被观察的对象为顶级 data 下的，毕竟后面 observe 还会递归使用。</li></ol><h2 id="2-观察者（Observer）"><a href="#2-观察者（Observer）" class="headerlink" title="2. 观察者（Observer）"></a>2. 观察者（Observer）</h2><h3 id="obseve"><a href="#obseve" class="headerlink" title="obseve"></a>obseve</h3><p>开始观察属性调用了 observe 方法，我们进入到<a href="https://github.com/vuejs/vue/blob/v2.6.11/src/core/observer/index.js">vue/src/core/observer/index.js</a>内</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Attempt to create an observer instance for a value,</span><span class="hljs-comment"> * returns the new observer if successfully observed,</span><span class="hljs-comment"> * or the existing observer if the value already has one.</span><span class="hljs-comment"> */</span><span class="hljs-comment">// asRootData是根对象标识，调用observe的要么是跟对象要么是根对象下面的属性递归时</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">value: any, asRootData: ?boolean</span>): <span class="hljs-title">Observer</span> | <span class="hljs-title">void</span> </span>&#123;  <span class="hljs-keyword">if</span> (!isObject(value) || value <span class="hljs-keyword">instanceof</span> VNode) &#123;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">let</span> ob: Observer | <span class="hljs-keyword">void</span>;  <span class="hljs-keyword">if</span> (hasOwn(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="hljs-keyword">instanceof</span> Observer) &#123;    <span class="hljs-comment">// 如果对象上有__ob__则使用__ob__属性</span>    ob = value.__ob__;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (    shouldObserve &amp;&amp;    !isServerRendering() &amp;&amp;    (<span class="hljs-built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;    <span class="hljs-built_in">Object</span>.isExtensible(value) &amp;&amp;    !value._isVue  ) &#123;    ob = <span class="hljs-keyword">new</span> Observer(value);  &#125;  <span class="hljs-keyword">if</span> (asRootData &amp;&amp; ob) &#123;    <span class="hljs-comment">// 如果是根部对象，即非对象内属性，则计数一下依赖到这个对象的组件实例</span>    ob.vmCount++;  &#125;  <span class="hljs-keyword">return</span> ob;&#125;</code></pre><p>可以看到 observe 方法其实主要做的就是实例化 Observer 类，而 Observer 就是 Vue 响应式的核心之一了，我这里称之为<code>观察者</code>,因为是用来观察数据变化的。</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Observer class that is attached to each observed</span><span class="hljs-comment"> * object. Once attached, the observer converts the target</span><span class="hljs-comment"> * object&#x27;s property keys into getter/setters that</span><span class="hljs-comment"> * collect dependencies and dispatch updates.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;  value: any;  dep: Dep;  vmCount: number; <span class="hljs-comment">// number of vms that have this object as root $data</span>  <span class="hljs-keyword">constructor</span>(value: any) &#123;    <span class="hljs-built_in">this</span>.value = value;    <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep(); <span class="hljs-comment">// 在实例上挂载订阅器，这个订阅器是对象本身的订阅器，用于收集对象更改、移除、数组变化</span>    <span class="hljs-built_in">this</span>.vmCount = <span class="hljs-number">0</span>;    def(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-built_in">this</span>); <span class="hljs-comment">// 在对象上将自己挂载于__ob__下</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;      <span class="hljs-keyword">if</span> (hasProto) &#123;        <span class="hljs-comment">// 这里将会劫持array原型链上的方法，使其可以响应式</span>        protoAugment(value, arrayMethods);      &#125; <span class="hljs-keyword">else</span> &#123;        copyAugment(value, arrayMethods, arrayKeys);      &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">       * 遍历数组，但是并没有劫持数组下标，仅仅只是对数组内所有值都走一次observe方法，这里其实完全可以劫持,</span><span class="hljs-comment">       * 没这么做是因为这样子得不偿失，数组长度可能整天变动，性能会比较低下，所以选择劫持数组更改的方法（splice）等</span><span class="hljs-comment">       */</span>      <span class="hljs-built_in">this</span>.observeArray(value);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">this</span>.walk(value); <span class="hljs-comment">// 遍历并劫持对象中的所有属性</span>    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Walk through all properties and convert them into</span><span class="hljs-comment">   * getter/setters. This method should only be called when</span><span class="hljs-comment">   * value type is Object.</span><span class="hljs-comment">   */</span>  walk(obj: <span class="hljs-built_in">Object</span>) &#123;    <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;      defineReactive(obj, keys[I]); <span class="hljs-comment">// 劫持对象中所有属性值</span>    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Observe a list of Array items.</span><span class="hljs-comment">   */</span>  observeArray(items: <span class="hljs-built_in">Array</span>&lt;any&gt;) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) &#123;      observe(items[I]); <span class="hljs-comment">// 数组里循环观察每个值</span>    &#125;  &#125;&#125;</code></pre><h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h3><p>defineReactive 就是如何劫持对象中属性的核心</p><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Define a reactive property on an Object.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">  obj: Object,</span></span><span class="hljs-function"><span class="hljs-params">  key: string,</span></span><span class="hljs-function"><span class="hljs-params">  val: any, <span class="hljs-regexp">//</span> 这个其实也是属性值的闭包</span></span><span class="hljs-function"><span class="hljs-params">  customSetter?: ?Function,</span></span><span class="hljs-function"><span class="hljs-params">  shallow?: boolean</span></span><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep(); <span class="hljs-comment">// 属性订阅器，闭包内的，所以需要dep栈调取</span>  <span class="hljs-keyword">const</span> property = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, key); <span class="hljs-comment">// 获取对象属性本身描述符</span>  <span class="hljs-keyword">if</span> (property &amp;&amp; property.configurable === <span class="hljs-literal">false</span>) &#123;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-comment">// cater for pre-defined getter/setters</span>  <span class="hljs-keyword">const</span> getter = property &amp;&amp; property.get;  <span class="hljs-keyword">const</span> setter = property &amp;&amp; property.set;  <span class="hljs-keyword">if</span> ((!getter || setter) &amp;&amp; <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;    val = obj[key];  &#125;  <span class="hljs-keyword">let</span> childOb = !shallow &amp;&amp; observe(val); <span class="hljs-comment">// 获取值的观察者</span>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;    enumerable: <span class="hljs-literal">true</span>,    configurable: <span class="hljs-literal">true</span>,    get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-comment">// 这里就是最核心的getter，在获取属性值的时机收集依赖</span>      <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val;      <span class="hljs-keyword">if</span> (Dep.target) &#123;        dep.depend(); <span class="hljs-comment">// 依赖收集（将当前的watcher加入dep依赖中）</span>        <span class="hljs-keyword">if</span> (childOb) &#123;          childOb.dep.depend(); <span class="hljs-comment">// 如果有子订阅器也收集本次watcher</span>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;            dependArray(value);          &#125;        &#125;      &#125;      <span class="hljs-keyword">return</span> value;    &#125;,    set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span>(<span class="hljs-params">newVal</span>) </span>&#123;      <span class="hljs-comment">// 这里就是最核心的setter，在设置属性值的时机通知依赖更新</span>      <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val;      <span class="hljs-comment">/* eslint-disable no-self-compare */</span>      <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        <span class="hljs-comment">// 这里是个有趣的点，自我对比主要是NaN不等于自己</span>        <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">/* eslint-enable no-self-compare */</span>      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;        customSetter();      &#125;      <span class="hljs-comment">// #7981: for accessor properties without setter</span>      <span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) <span class="hljs-keyword">return</span>;      <span class="hljs-keyword">if</span> (setter) &#123;        setter.call(obj, newVal);      &#125; <span class="hljs-keyword">else</span> &#123;        val = newVal;      &#125;      childOb = !shallow &amp;&amp; observe(newVal); <span class="hljs-comment">// 获取新的赋值的观察者</span>      dep.notify(); <span class="hljs-comment">// 订阅器通知更新</span>    &#125;,  &#125;);&#125;</code></pre><p>看到这里或许会有几个疑惑点：</p><ul><li>Observer 类中初始化了一个<code>订阅器</code>，而 defineReactive 中也产生了个在闭包中的<code>订阅器</code>。其实<code>观察者</code>中的<code>订阅器</code>是对这个对象本身的赋值，数组变化的订阅；而闭包内的<code>订阅器</code>则是订阅对象内的属性的。</li><li>(newVal !== newVal &amp;&amp; value !== value)，这一句是为了判断 NaN，因为 NaN 不等于自身。</li></ul><p>到这里，就已经做好了对数据的劫持了，即获取操作会让订阅器知道并收集依赖，设置操作会通知订阅器更新。</p><h2 id="3-订阅器（Dep）"><a href="#3-订阅器（Dep）" class="headerlink" title="3. 订阅器（Dep）"></a>3. 订阅器（Dep）</h2><p>Dep 我这里称之为<code>订阅器</code>，它的作用是做了<code>观察者</code>和<code>订阅者</code>直接通信的桥梁，在<a href="https://github.com/vuejs/vue/blob/v2.6.11/src/core/observer/dep.js">vue/src/core/observer/dep.js</a>内。</p><p><code>订阅器</code>内维护着一个对当前订阅了的<code>订阅者</code>列表，而该<code>订阅器</code>又被<code>观察者</code>持有着。所以：</p><ul><li><p>当<code>观察者</code>被获取值的时候，当前 Dep.target 可能会挂载着一个<code>订阅者</code>，此时<code>订阅器</code>会将该<code>订阅者</code>收集起来，意义就是可以认为：当前<code>订阅者</code>执行更新行为（渲染或者获取值）的时候，触发了<code>观察者</code>获取值操作，所以该<code>订阅者</code>依赖这个<code>观察者</code>的更新。</p></li><li><p>当<code>观察者</code>被赋值时，<code>观察者</code>触发更新时会通知<code>订阅器</code>，<code>订阅器</code>会让所有挂载在自己身上的<code>订阅者</code>更新；而<code>订阅者</code>更新将会触发<code>观察者</code>取值，如此循环。</p></li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> type Watcher <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./watcher&#x27;</span>;<span class="hljs-keyword">import</span> &#123; remove &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span>;<span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../config&#x27;</span>;<span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * A dep is an observable that can have multiple</span><span class="hljs-comment"> * directives subscribing to it.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;  <span class="hljs-keyword">static</span> target: ?Watcher; <span class="hljs-comment">// 当前的订阅者</span>  id: number;  subs: <span class="hljs-built_in">Array</span>&lt;Watcher&gt;; <span class="hljs-comment">// 订阅了这个订阅器的所有订阅者集合</span>  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-built_in">this</span>.id = uid++;    <span class="hljs-built_in">this</span>.subs = [];  &#125;  <span class="hljs-comment">// 添加订阅者</span>  addSub(sub: Watcher) &#123;    <span class="hljs-built_in">this</span>.subs.push(sub);  &#125;  <span class="hljs-comment">// 移除订阅者</span>  removeSub(sub: Watcher) &#123;    remove(<span class="hljs-built_in">this</span>.subs, sub);  &#125;  <span class="hljs-comment">// 依赖收集，将当前的订阅器递收集当前的订阅者</span>  depend() &#123;    <span class="hljs-keyword">if</span> (Dep.target) &#123;      Dep.target.addDep(<span class="hljs-built_in">this</span>);    &#125;  &#125;  <span class="hljs-comment">// 通知所有订阅器内订阅者们更新</span>  notify() &#123;    <span class="hljs-comment">// stabilize the subscriber list first</span>    <span class="hljs-keyword">const</span> subs = <span class="hljs-built_in">this</span>.subs.slice();    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;      <span class="hljs-comment">// subs aren&#x27;t sorted in scheduler if not running async</span>      <span class="hljs-comment">// we need to sort them now to make sure they fire in correct</span>      <span class="hljs-comment">// order</span>      subs.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.id - b.id);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123;      subs[i].update();    &#125;  &#125;&#125;<span class="hljs-comment">// The current target watcher being evaluated.</span><span class="hljs-comment">// This is globally unique because only one watcher</span><span class="hljs-comment">// can be evaluated at a time.</span>Dep.target = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 因为js单线程、同步机制，同时只会有一个watcher在被处理</span><span class="hljs-keyword">const</span> targetStack = []; <span class="hljs-comment">// Dep.target的栈</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushTarget</span>(<span class="hljs-params">target: ?Watcher</span>) </span>&#123;  <span class="hljs-comment">// 入栈</span>  targetStack.push(target);  Dep.target = target;&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popTarget</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 出栈</span>  targetStack.pop();  Dep.target = targetStack[targetStack.length - <span class="hljs-number">1</span>];&#125;</code></pre><h3 id="Dep-target"><a href="#Dep-target" class="headerlink" title="Dep.target"></a>Dep.target</h3><p>这个是 Dep 类上的静态属性，就是说全局只有一个，也是当前被处理的<code>订阅者</code>Watcher 被挂载的地方。但是这里就有问题了，其实因为 js 单线程的原因，同时只有一个 Watcher 被处理，为什么需要有个 targetStack 即模拟出一个栈去管理呢？</p><h4 id="为什么需要用栈来管理-Dep-target"><a href="#为什么需要用栈来管理-Dep-target" class="headerlink" title="为什么需要用栈来管理 Dep.target"></a>为什么需要用栈来管理 Dep.target</h4><p>在 Vue1 中仅仅是依靠 Dep.target 里进行依赖收集和当前处理中的订阅器，因为 Vue1 视图更新采用的是细粒度绑定的方式，即可以理解为</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- root --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  &#123;&#123; a &#125;&#125;  <span class="hljs-tag">&lt;<span class="hljs-name">my</span> <span class="hljs-attr">:text</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my</span>&gt;</span>  &#123;&#123; c &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- component my --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; b &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><p>会被解析成：</p><pre><code class="hljs javascript">watch(<span class="hljs-keyword">for</span> a) -&gt; directive(update &#123;&#123; a &#125;&#125;)watch(<span class="hljs-keyword">for</span> b) -&gt; directive(update &#123;&#123; b &#125;&#125;)watch(<span class="hljs-keyword">for</span> c) -&gt; directive(update &#123;&#123; c &#125;&#125;)</code></pre><p>由于渲染是细粒度绑定，所以在处理完一个数据视图绑定后才回处理新的。</p><p>而在 Vue2 中，视图会被抽象成 render 函数，一个 render 函数只会生成一个 watcher，其机理会可以理解为：</p><pre><code class="hljs javascript">renderRoot () &#123;    ...    renderMy ()    ...&#125;</code></pre><p>这里就包含了嵌套调用，只要有嵌套调用就会有调用栈，当调用 root 时当前 root watcher 入栈，执行到 my 渲染时，此时要中断 root 的 evaluate，而在 my 的 evaluate 结束后 root 将会继续执行，这就是 target 栈的意义</p><h2 id="4-订阅者（Watcher）"><a href="#4-订阅者（Watcher）" class="headerlink" title="4.订阅者（Watcher）"></a>4.订阅者（Watcher）</h2><p>Watcher 是数据变化后的行为的执行人，所以这里我称之为<code>订阅者</code>，在<a href="https://github.com/vuejs/vue/blob/v2.6.11/src/core/observer/watcher.js">vue/src/core/observer/watcher.js</a>内。</p><p>在了解<code>订阅者</code>之前，需要知道 Vue 中 Watcher 有三种，分别是：</p><ul><li>**<u>自定义 Watcher</u>**：用户自己创建的 watch 或$watch</li><li>**<u>计算 Watcher</u>**：声明计算属性时自动创建的 Watcher</li><li>**<u>渲染 Watcher</u>**：每个组件创建时都有个 Watcher</li></ul><p>而内部执行顺序是 <strong><u>计算 Watcher</u></strong> &rarr; <strong><u>自定义 Watcher</u></strong> &rarr; <strong><u>渲染 Watcher</u></strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;  warn,  remove,  isObject,  parsePath,  _Set <span class="hljs-keyword">as</span> <span class="hljs-built_in">Set</span>,  handleError,  noop,&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span>;<span class="hljs-keyword">import</span> &#123; traverse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./traverse&#x27;</span>;<span class="hljs-keyword">import</span> &#123; queueWatcher &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./scheduler&#x27;</span>;<span class="hljs-keyword">import</span> Dep, &#123; pushTarget, popTarget &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dep&#x27;</span>;<span class="hljs-keyword">import</span> type &#123; SimpleSet &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span>;<span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * A watcher parses an expression, collects dependencies,</span><span class="hljs-comment"> * and fires callback when the expression value changes.</span><span class="hljs-comment"> * This is used for both the $watch() api and directives.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;  vm: Component; <span class="hljs-comment">// 组件实例</span>  expression: string; <span class="hljs-comment">// 取值函数或者函数名，用于错误提示的</span>  cb: <span class="hljs-built_in">Function</span>; <span class="hljs-comment">// 更新后的回调函数（一般在自定义watcher才存在，其实就是watch的handler属性）</span>  id: number;  deep: boolean;  user: boolean; <span class="hljs-comment">// 用于错误处理，只有自定义watcher为true</span>  lazy: boolean; <span class="hljs-comment">// 惰性取值，在计算wathcer中为true</span>  sync: boolean;  dirty: boolean; <span class="hljs-comment">// 标记是否已被惰性求值，如果是就返回不调用get</span>  active: boolean;  deps: <span class="hljs-built_in">Array</span>&lt;Dep&gt;; <span class="hljs-comment">// 当前依赖器表</span>  newDeps: <span class="hljs-built_in">Array</span>&lt;Dep&gt;; <span class="hljs-comment">// 即将到来的依赖器表</span>  depIds: SimpleSet; <span class="hljs-comment">// 当前依赖器id表</span>  newDepIds: SimpleSet; <span class="hljs-comment">// 即将到来的依赖器id表</span>  before: ?<span class="hljs-built_in">Function</span>; <span class="hljs-comment">// 用于队列取值前触发，只在渲染watcher中执行beforeUpdate事件发布</span>  getter: <span class="hljs-built_in">Function</span>; <span class="hljs-comment">// 取值函数，用于触发getter形成依赖收集闭环，自定义watcher里会变成属性取值函数或者$watch中的取值方法，计算watcher里为computed的getter，渲染watcher里为render函数，包含vnode创建和打补丁等</span>  value: any; <span class="hljs-comment">// 值</span>  <span class="hljs-keyword">constructor</span>(    vm: Component,    expOrFn: string | Function,    cb: Function,    options?: ?Object,    isRenderWatcher?: boolean  ) &#123;    <span class="hljs-built_in">this</span>.vm = vm;    <span class="hljs-keyword">if</span> (isRenderWatcher) &#123;      vm._watcher = <span class="hljs-built_in">this</span>;    &#125;    vm._watchers.push(<span class="hljs-built_in">this</span>);    <span class="hljs-comment">// options</span>    <span class="hljs-keyword">if</span> (options) &#123;      <span class="hljs-built_in">this</span>.deep = !!options.deep;      <span class="hljs-built_in">this</span>.user = !!options.user;      <span class="hljs-built_in">this</span>.lazy = !!options.lazy;      <span class="hljs-built_in">this</span>.sync = !!options.sync;      <span class="hljs-built_in">this</span>.before = options.before;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">this</span>.deep = <span class="hljs-built_in">this</span>.user = <span class="hljs-built_in">this</span>.lazy = <span class="hljs-built_in">this</span>.sync = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-built_in">this</span>.cb = cb;    <span class="hljs-built_in">this</span>.id = ++uid; <span class="hljs-comment">// uid for batching</span>    <span class="hljs-built_in">this</span>.active = <span class="hljs-literal">true</span>;    <span class="hljs-built_in">this</span>.dirty = <span class="hljs-built_in">this</span>.lazy; <span class="hljs-comment">// for lazy watchers</span>    <span class="hljs-built_in">this</span>.deps = [];    <span class="hljs-built_in">this</span>.newDeps = [];    <span class="hljs-built_in">this</span>.depIds = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();    <span class="hljs-built_in">this</span>.newDepIds = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();    <span class="hljs-built_in">this</span>.expression =      process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> ? expOrFn.toString() : <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-comment">// parse expression for getter</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expOrFn === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;      <span class="hljs-built_in">this</span>.getter = expOrFn; <span class="hljs-comment">// 如果取值函数是个函数，则直接赋值给getter</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-built_in">this</span>.getter = parsePath(expOrFn); <span class="hljs-comment">// 如果取值函数是个字符串（自定义watcher内属性路径函数名），则生成一个取对象属性的函数</span>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.getter) &#123;        <span class="hljs-comment">// 这种情况出现在字符串对象路径不为.取值方式，使用了[ ]取属性方式</span>        <span class="hljs-built_in">this</span>.getter = noop;        process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp;          warn(            <span class="hljs-string">`Failed watching path: &quot;<span class="hljs-subst">$&#123;expOrFn&#125;</span>&quot; `</span> +              <span class="hljs-string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +              <span class="hljs-string">&#x27;For full control, use a function instead.&#x27;</span>,            vm          );      &#125;    &#125;    <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.lazy <span class="hljs-comment">// 如果不是惰性取值则立刻取值</span>      ? <span class="hljs-literal">undefined</span>      : <span class="hljs-built_in">this</span>.get();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Evaluate the getter, and re-collect dependencies.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// 取值操作，这里会触发所有观察者getter收集依赖</span>  get() &#123;    pushTarget(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 当前订阅者入订阅器栈</span>    <span class="hljs-keyword">let</span> value;    <span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">this</span>.vm;    <span class="hljs-keyword">try</span> &#123;      value = <span class="hljs-built_in">this</span>.getter.call(vm, vm); <span class="hljs-comment">// 取一次值，这里会触发所有数据观察者收集依赖</span>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.user) &#123;        handleError(e, vm, <span class="hljs-string">`getter for watcher &quot;<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.expression&#125;</span>&quot;`</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> e;      &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-comment">// &quot;touch&quot; every property so they are all tracked as</span>      <span class="hljs-comment">// dependencies for deep watching</span>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.deep) &#123;        traverse(value); <span class="hljs-comment">// 递归访问所有属性值，触发所有getter</span>      &#125;      popTarget(); <span class="hljs-comment">// 出栈</span>      <span class="hljs-built_in">this</span>.cleanupDeps(); <span class="hljs-comment">// 清理上一次订阅器的关联表</span>    &#125;    <span class="hljs-keyword">return</span> value;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Add a dependency to this directive.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// 添加订阅器关联，确保相同的依赖不会重复添加</span>  addDep(dep: Dep) &#123;    <span class="hljs-keyword">const</span> id = dep.id;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.newDepIds.has(id)) &#123;      <span class="hljs-built_in">this</span>.newDepIds.add(id);      <span class="hljs-built_in">this</span>.newDeps.push(dep);      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.depIds.has(id)) &#123;        dep.addSub(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 为订阅器添加当前订阅者</span>      &#125;    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Clean up for dependency collection.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// 移除不在新订阅器id表内的订阅器，每次更新都会将不再需要订阅的移除</span>  cleanupDeps() &#123;    <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">this</span>.deps.length;    <span class="hljs-keyword">while</span> (i--) &#123;      <span class="hljs-keyword">const</span> dep = <span class="hljs-built_in">this</span>.deps[i];      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.newDepIds.has(dep.id)) &#123;        dep.removeSub(<span class="hljs-built_in">this</span>);      &#125;    &#125;    <span class="hljs-keyword">let</span> tmp = <span class="hljs-built_in">this</span>.depIds; <span class="hljs-comment">// 新的表加入当前表字段中，然后将新表清空</span>    <span class="hljs-built_in">this</span>.depIds = <span class="hljs-built_in">this</span>.newDepIds;    <span class="hljs-built_in">this</span>.newDepIds = tmp;    <span class="hljs-built_in">this</span>.newDepIds.clear();    tmp = <span class="hljs-built_in">this</span>.deps;    <span class="hljs-built_in">this</span>.deps = <span class="hljs-built_in">this</span>.newDeps;    <span class="hljs-built_in">this</span>.newDeps = tmp;    <span class="hljs-built_in">this</span>.newDeps.length = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Subscriber interface.</span><span class="hljs-comment">   * Will be called when a dependency changes.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// 更新订阅者接口，如果是惰性取值则标记dirty，然后在evaluate中才更新取</span>  update() &#123;    <span class="hljs-comment">/* istanbul ignore else */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.lazy) &#123;      <span class="hljs-comment">// 计算watcher会懒取值</span>      <span class="hljs-built_in">this</span>.dirty = <span class="hljs-literal">true</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sync) &#123;      <span class="hljs-comment">// 这个同步更新目前没见到,其实在自定义watcher可以设置sync让其同步更新</span>      <span class="hljs-built_in">this</span>.run();    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 自定义watcher和渲染会走异步队列</span>      queueWatcher(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 并不是每次数据改变就立刻触发，而是推入队列中异步更新订阅者</span>    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Scheduler job interface.</span><span class="hljs-comment">   * Will be called by the scheduler.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// 更新订阅者的任务，也是在调度器队列里的任务最终回调</span>  run() &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.active) &#123;      <span class="hljs-keyword">const</span> value = <span class="hljs-built_in">this</span>.get(); <span class="hljs-comment">// 取一次值，这里会触发所有数据观察者收集依赖</span>      <span class="hljs-keyword">if</span> (        value !== <span class="hljs-built_in">this</span>.value ||        <span class="hljs-comment">// Deep watchers and watchers on Object/Arrays should fire even</span>        <span class="hljs-comment">// when the value is the same, because the value may</span>        <span class="hljs-comment">// have mutated.</span>        isObject(value) ||        <span class="hljs-built_in">this</span>.deep      ) &#123;        <span class="hljs-comment">// 当新值与旧值不一致，或者是对象、数组，或者配置了deep就触发回调</span>        <span class="hljs-comment">// set new value</span>        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-built_in">this</span>.value;        <span class="hljs-built_in">this</span>.value = value;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.user) &#123;          <span class="hljs-keyword">try</span> &#123;            <span class="hljs-built_in">this</span>.cb.call(<span class="hljs-built_in">this</span>.vm, value, oldValue); <span class="hljs-comment">// 这里的cb就是上面说的更新后的回调，大部分情况在watch的handler</span>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;            handleError(              e,              <span class="hljs-built_in">this</span>.vm,              <span class="hljs-string">`callback for watcher &quot;<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.expression&#125;</span>&quot;`</span>            );          &#125;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-built_in">this</span>.cb.call(<span class="hljs-built_in">this</span>.vm, value, oldValue); <span class="hljs-comment">// 这里的cb就是上面说的更新后的回调，大部分情况在watch的handler</span>        &#125;      &#125;    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Evaluate the value of the watcher.</span><span class="hljs-comment">   * This only gets called for lazy watchers.</span><span class="hljs-comment">   */</span>  evaluate() &#123;    <span class="hljs-comment">// 这里在dirty为true时才会调用，在计算watcher内的</span>    <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.get(); <span class="hljs-comment">// 获取值，并在外部获取watcher.value</span>    <span class="hljs-built_in">this</span>.dirty = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 获取过了就改回去</span>  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Depend on all deps collected by this watcher.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 这里是将本次watcher在订阅中的订阅器都被栈顶的watcher订阅，调用时是computed的getter，</span><span class="hljs-comment">   * 此时计算watcher已出栈，栈内是渲染watcher，通过遍历本次watcher里的deps库，让渲染watcher都去订阅他们，</span><span class="hljs-comment">   * 意思是，计算属性依赖的data都会被渲染watcher订阅</span><span class="hljs-comment">   */</span>  depend() &#123;    <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">this</span>.deps.length;    <span class="hljs-keyword">while</span> (i--) &#123;      <span class="hljs-built_in">this</span>.deps[i].depend();    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Remove self from all dependencies&#x27; subscriber list.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// 移除所有订阅器上自身的订阅，在组件移除，$watch返回的unwatch上使用</span>  teardown() &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.active) &#123;      <span class="hljs-comment">// remove self from vm&#x27;s watcher list</span>      <span class="hljs-comment">// this is a somewhat expensive operation so we skip it</span>      <span class="hljs-comment">// if the vm is being destroyed.</span>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.vm._isBeingDestroyed) &#123;        remove(<span class="hljs-built_in">this</span>.vm._watchers, <span class="hljs-built_in">this</span>);      &#125;      <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">this</span>.deps.length;      <span class="hljs-keyword">while</span> (i--) &#123;        <span class="hljs-built_in">this</span>.deps[i].removeSub(<span class="hljs-built_in">this</span>);      &#125;      <span class="hljs-built_in">this</span>.active = <span class="hljs-literal">false</span>;    &#125;  &#125;&#125;</code></pre><h4 id="Watcher-内的-depend-有什么用"><a href="#Watcher-内的-depend-有什么用" class="headerlink" title="Watcher 内的 depend 有什么用"></a>Watcher 内的 depend 有什么用</h4><p>该方法会在 computed 属性内调用 getter 时调用。</p><p>depend 在 Watcher 类里的意思是，将本次<code>计算Watcher</code>所订阅的属性，都会被<code>渲染Watcher</code>订阅，如此知道渲染其实直接订阅的是 computed 里的依赖，并非订阅了 computed，视图并不知道 computed 的更新。证明方法是：computed 内设置 get 和 set，并且使用一个非 observable 的数据，如直接在 window 上定义一个变量，此次 computed 关联他，记得在更改时，调用下 vm 上的_computedWatchers 内本次 watcher 的 run，因为无劫持数据，computed 不知道你的数据更新了。此时更改 computed 数据，视图并未更新。</p><h2 id="异步执行调度器"><a href="#异步执行调度器" class="headerlink" title="异步执行调度器"></a>异步执行调度器</h2><p>这块是 Vue 内的异步执行调度器，在<a href="https://github.com/vuejs/vue/blob/v2.6.11/src/core/observer/scheduler.js">vue/src/core/scheduler.js</a>内。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> type Watcher <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./watcher&#x27;</span>;<span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../config&#x27;</span>;<span class="hljs-keyword">import</span> &#123; callHook, activateChildComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../instance/lifecycle&#x27;</span>;<span class="hljs-keyword">import</span> &#123; warn, nextTick, devtools, inBrowser, isIE &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MAX_UPDATE_COUNT = <span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> queue: <span class="hljs-built_in">Array</span>&lt;Watcher&gt; = [];<span class="hljs-keyword">const</span> activatedChildren: <span class="hljs-built_in">Array</span>&lt;Component&gt; = [];<span class="hljs-keyword">let</span> has: &#123; [key: number]: ?<span class="hljs-literal">true</span> &#125; = &#123;&#125;;<span class="hljs-keyword">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;;<span class="hljs-keyword">let</span> waiting = <span class="hljs-literal">false</span>;<span class="hljs-keyword">let</span> flushing = <span class="hljs-literal">false</span>;<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Reset the scheduler&#x27;s state.</span><span class="hljs-comment"> */</span><span class="hljs-comment">// 重置运行状态的方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetSchedulerState</span>(<span class="hljs-params"></span>) </span>&#123;  index = queue.length = activatedChildren.length = <span class="hljs-number">0</span>;  has = &#123;&#125;;  <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;    circular = &#123;&#125;;  &#125;  waiting = flushing = <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">// Async edge case #6566 requires saving the timestamp when event listeners are</span><span class="hljs-comment">// attached. However, calling performance.now() has a perf overhead especially</span><span class="hljs-comment">// if the page has thousands of event listeners. Instead, we take a timestamp</span><span class="hljs-comment">// every time the scheduler flushes and use that for all event listeners</span><span class="hljs-comment">// attached during that flush.</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> currentFlushTimestamp = <span class="hljs-number">0</span>;<span class="hljs-comment">// Async edge case fix requires storing an event listener&#x27;s attach timestamp.</span><span class="hljs-keyword">let</span> getNow: <span class="hljs-function">() =&gt;</span> number = <span class="hljs-built_in">Date</span>.now;<span class="hljs-comment">// Determine what event timestamp the browser is using. Annoyingly, the</span><span class="hljs-comment">// timestamp can either be hi-res (relative to page load) or low-res</span><span class="hljs-comment">// (relative to UNIX epoch), so in order to compare time we have to use the</span><span class="hljs-comment">// same timestamp type when saving the flush timestamp.</span><span class="hljs-comment">// All IE versions use low-res event timestamps, and have problematic clock</span><span class="hljs-comment">// implementations (#9632)</span><span class="hljs-keyword">if</span> (inBrowser &amp;&amp; !isIE) &#123;  <span class="hljs-keyword">const</span> performance = <span class="hljs-built_in">window</span>.performance;  <span class="hljs-keyword">if</span> (    performance &amp;&amp;    <span class="hljs-keyword">typeof</span> performance.now === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp;    getNow() &gt; <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">&#x27;Event&#x27;</span>).timeStamp  ) &#123;    <span class="hljs-comment">// if the event timestamp, although evaluated AFTER the Date.now(), is</span>    <span class="hljs-comment">// smaller than it, it means the event is using a hi-res timestamp,</span>    <span class="hljs-comment">// and we need to use the hi-res version for event listener timestamps as</span>    <span class="hljs-comment">// well.</span>    getNow = <span class="hljs-function">() =&gt;</span> performance.now();  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Flush both queues and run the watchers.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSchedulerQueue</span>(<span class="hljs-params"></span>) </span>&#123;  currentFlushTimestamp = getNow();  flushing = <span class="hljs-literal">true</span>;  <span class="hljs-keyword">let</span> watcher, id;  <span class="hljs-comment">// Sort queue before flush.</span>  <span class="hljs-comment">// This ensures that:</span>  <span class="hljs-comment">// 1. Components are updated from parent to child. (because parent is always</span>  <span class="hljs-comment">//    created before the child)</span>  <span class="hljs-comment">// 2. A component&#x27;s user watchers are run before its render watcher (because</span>  <span class="hljs-comment">//    user watchers are created before the render watcher)</span>  <span class="hljs-comment">// 3. If a component is destroyed during a parent component&#x27;s watcher run,</span>  <span class="hljs-comment">//    its watchers can be skipped.</span>  queue.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.id - b.id); <span class="hljs-comment">// 这里需要排一个序，确保更新从父再到子，自定义wathcer需要早于渲染watcher，如果一个组件在父组件的watcher运行中销毁，他也可以被跳过</span>  <span class="hljs-comment">// do not cache length because more watchers might be pushed</span>  <span class="hljs-comment">// as we run existing watchers</span>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; queue.length; index++) &#123;    watcher = queue[index];    <span class="hljs-keyword">if</span> (watcher.before) &#123;      watcher.before();    &#125;    id = watcher.id;    has[id] = <span class="hljs-literal">null</span>;    watcher.run();    <span class="hljs-comment">// in dev build, check and stop circular updates.</span>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; has[id] != <span class="hljs-literal">null</span>) &#123;      circular[id] = (circular[id] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;        warn(          <span class="hljs-string">&#x27;You may have an infinite update loop &#x27;</span> +            (watcher.user              ? <span class="hljs-string">`in watcher with expression &quot;<span class="hljs-subst">$&#123;watcher.expression&#125;</span>&quot;`</span>              : <span class="hljs-string">`in a component render function.`</span>),          watcher.vm        );        <span class="hljs-keyword">break</span>;      &#125;    &#125;  &#125;  <span class="hljs-comment">// keep copies of post queues before resetting state</span>  <span class="hljs-keyword">const</span> activatedQueue = activatedChildren.slice();  <span class="hljs-keyword">const</span> updatedQueue = queue.slice();  resetSchedulerState(); <span class="hljs-comment">// 重置状态</span>  <span class="hljs-comment">// call component updated and activated hooks</span>  callActivatedHooks(activatedQueue);  callUpdatedHooks(updatedQueue);  <span class="hljs-comment">// devtool hook</span>  <span class="hljs-comment">/* istanbul ignore if */</span>  <span class="hljs-keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;    devtools.emit(<span class="hljs-string">&#x27;flush&#x27;</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callUpdatedHooks</span>(<span class="hljs-params">queue</span>) </span>&#123;  <span class="hljs-keyword">let</span> i = queue.length;  <span class="hljs-keyword">while</span> (i--) &#123;    <span class="hljs-keyword">const</span> watcher = queue[i];    <span class="hljs-keyword">const</span> vm = watcher.vm;    <span class="hljs-keyword">if</span> (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;      callHook(vm, <span class="hljs-string">&#x27;updated&#x27;</span>);    &#125;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Queue a kept-alive component that was activated during patch.</span><span class="hljs-comment"> * The queue will be processed after the entire tree has been patched.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueActivatedComponent</span>(<span class="hljs-params">vm: Component</span>) </span>&#123;  <span class="hljs-comment">// setting _inactive to false here so that a render function can</span>  <span class="hljs-comment">// rely on checking whether it&#x27;s in an inactive tree (e.g. router-view)</span>  vm._inactive = <span class="hljs-literal">false</span>;  activatedChildren.push(vm);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callActivatedHooks</span>(<span class="hljs-params">queue</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; queue.length; i++) &#123;    queue[i]._inactive = <span class="hljs-literal">true</span>;    activateChildComponent(queue[i], <span class="hljs-literal">true</span> <span class="hljs-comment">/* true */</span>);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Push a watcher into the watcher queue.</span><span class="hljs-comment"> * Jobs with duplicate IDs will be skipped unless it&#x27;s</span><span class="hljs-comment"> * pushed when the queue is being flushed.</span><span class="hljs-comment"> */</span><span class="hljs-comment">// 这里是将需要更新的watcher推进队列中，在下一个tick批量运行</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueWatcher</span>(<span class="hljs-params">watcher: Watcher</span>) </span>&#123;  <span class="hljs-keyword">const</span> id = watcher.id;  <span class="hljs-keyword">if</span> (has[id] == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// 先保证同一个watcher只会添加一次</span>    has[id] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span> (!flushing) &#123;      queue.push(watcher); <span class="hljs-comment">// 如果没在运行中就直接插入队列</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// if already flushing, splice the watcher based on its id</span>      <span class="hljs-comment">// if already past its id, it will be run next immediately.</span>      <span class="hljs-keyword">let</span> i = queue.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;        i--;      &#125;      queue.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, watcher); <span class="hljs-comment">// 在运行中就找到id所在的位置插入</span>    &#125;    <span class="hljs-comment">// queue the flush</span>    <span class="hljs-keyword">if</span> (!waiting) &#123;      <span class="hljs-comment">// 在准备运行中就不要再启动了</span>      waiting = <span class="hljs-literal">true</span>;      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;        flushSchedulerQueue();        <span class="hljs-keyword">return</span>;      &#125;      nextTick(flushSchedulerQueue); <span class="hljs-comment">// nextTick即下一微任务优先，不支持就下一宏任务</span>    &#125;  &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个 Vue 的响应式源码大概就是这样，需要 Observer、Dep、Watcher 互相配合，而数据流动是这样的：</p><ol><li>new Vue 时获取 data 并走 Observer，对数据劫持了 getter 和 setter，并且创建了 Dep 并持有了它。</li><li>渲染模板时创建 Watcher，并调用 get 更新一次，watcher 推入 Dep 栈中，并触发渲染，渲染时使用到了 data 中的数据会触发所有数据获取操作。</li><li>触发 getter 内的 dep.depend 收集依赖，将 Dep.target 中的 watcher 收集到自己身上，watcher 也将当前 dep 收集到自己身上。</li><li>到这里初次渲染绑定依赖完成。</li><li>更改数据触发数据观察者内的 setter 调用 dep.notify，通知 dep 内所有 wathcer。</li><li>watcher 更新，这时候就是重复上面第 2 步的步骤了。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Vue</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从标准实现入手理解 Promise</title>
    <link href="/%E4%BB%8E%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%E5%85%A5%E6%89%8B%E7%90%86%E8%A7%A3%20Promise/"/>
    <url>/%E4%BB%8E%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%E5%85%A5%E6%89%8B%E7%90%86%E8%A7%A3%20Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="从标准实现入手理解-Promise"><a href="#从标准实现入手理解-Promise" class="headerlink" title="从标准实现入手理解 Promise"></a>从标准实现入手理解 Promise</h1><h2 id="为什么写这篇"><a href="#为什么写这篇" class="headerlink" title="为什么写这篇"></a>为什么写这篇</h2><p>网上解释已经一抓一大把，但是个人觉得大部分文章可以实现 Promise/A+，但是对真实细节没完全实现：</p><ul><li>真正的 microtask（大部分用的 setTimeout 代替）</li><li>then 传入回调函数返回 Promise 对象的情况</li><li>构造函数 executor 的细节，以及 executor 的 resolve 参数传入 Promise 对象的情况</li><li>Promise.resolve 传入 Promise 对象的情况</li><li>Promise 各种静态函数传入的是可迭代对象而非数组</li><li>介绍清楚循环调用阻止的情况和多次 resolve 阻止的情况</li></ul><p>本人用自己浅薄的知识尝试去覆盖最真实的 Promise 所有实现情况，并且用纯 js 实现，从中理解到真正的 Promise 是怎么样的。</p><h2 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h2><p><code>Promise</code> 是异步编程的一种解决方案，比传统的解决方案回调函数和事件更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 API，各种异步操作都可以用同样的方法进行处理，<strong>并非只能解决读取接口这种异步操作</strong>。</p><h2 id="在此之前如何解决异步操作"><a href="#在此之前如何解决异步操作" class="headerlink" title="在此之前如何解决异步操作"></a>在此之前如何解决异步操作</h2><p>在 Promise 出现之前其实也有出现了类 Promise 的库，例如<a href="https://github.com/kriskowal/q">Q</a>和<a href="https://github.com/jquery/jquery">JQuery</a>Deferred 等。但是通用的解决方案就是回调函数。</p><p>回调函数本身是没问题的，但是如果需要一个接一个调用（嵌套）时，很容易掉入回调地狱</p><pre><code class="hljs javascript">ajax(&#123;  url: <span class="hljs-string">&#x27;./index&#x27;</span>,  success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;    ajax(&#123;      url: value.url,      success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value2</span>) </span>&#123;        ajax(&#123;          url: value2.url,          success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value3</span>) </span>&#123;            ajax(&#123;              url: value3.url,              success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value4</span>) </span>&#123;                <span class="hljs-comment">// .. do something else</span>              &#125;,            &#125;);          &#125;,        &#125;);      &#125;,    &#125;);  &#125;,&#125;);</code></pre><p>在有 Promise 后就可以写成：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request = <span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    ajax(&#123;      url,      success: resolve,      fail: reject,    &#125;);  &#125;);request(<span class="hljs-string">&#x27;.index&#x27;</span>)  .then(<span class="hljs-function">(<span class="hljs-params">&#123; url &#125;</span>) =&gt;</span> request(url))  .then(<span class="hljs-function">(<span class="hljs-params">&#123; url &#125;</span>) =&gt;</span> request(url))  .then(<span class="hljs-function">(<span class="hljs-params">&#123; url &#125;</span>) =&gt;</span> request(url))  .then(<span class="hljs-function"><span class="hljs-params">value4</span> =&gt;</span> &#123;    <span class="hljs-comment">// .. do something else</span>  &#125;);</code></pre><p>甚至在配合 es2017 中的 async 函数可以写成：</p><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-keyword">const</span> &#123; url &#125; = <span class="hljs-keyword">await</span> request(<span class="hljs-string">&#x27;.index&#x27;</span>);  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">url</span>: url2 &#125; = <span class="hljs-keyword">await</span> request(url);  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">url</span>: url3 &#125; = <span class="hljs-keyword">await</span> request(url2);  <span class="hljs-keyword">const</span> value4 = <span class="hljs-keyword">await</span> request(url3);  <span class="hljs-comment">// .. do something else</span>&#125;)();</code></pre><p>整个代码就清晰易懂而且优雅简洁。</p><h2 id="Promise-特点"><a href="#Promise-特点" class="headerlink" title="Promise 特点"></a>Promise 特点</h2><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）<strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。<code>Promise</code>对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><h2 id="Promise-的-api-和用法"><a href="#Promise-的-api-和用法" class="headerlink" title="Promise 的 api 和用法"></a>Promise 的 api 和用法</h2><p>这里就不详细列举了，详细可以参考 es6 入门中的<a href="https://es6.ruanyifeng.com/#docs/promise">Promise 章</a>。<br>下面会默认读者已清楚了解 Promise 的 api。</p><h2 id="在开始前…"><a href="#在开始前…" class="headerlink" title="在开始前…"></a>在开始前…</h2><p>是否能说清楚下面打印的是什么，而且说出思路么？</p><p>1.</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;  res();  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 代码块1</span>&#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 代码块2</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      res();      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);    &#125;)      .then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 代码块3</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;          res();          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);        &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// 代码块4</span>          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>);        &#125;);      &#125;)      .then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 代码块5</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">9</span>);        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;          res();          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">10</span>);        &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// 代码块6</span>          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">12</span>);        &#125;);      &#125;);    <span class="hljs-built_in">Promise</span>.resolve()      .then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 代码块7</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);      &#125;)      .then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 代码块8</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">11</span>);      &#125;);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 代码块9</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>);  &#125;);</code></pre><p>2.</p><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.reject(  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      rej(<span class="hljs-number">133222</span>);      res(<span class="hljs-number">444</span>);    &#125;, <span class="hljs-number">2000</span>);  &#125;))  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs))  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs));</code></pre><p>3.</p><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      rej(<span class="hljs-number">133222</span>);      res(<span class="hljs-number">444</span>);    &#125;, <span class="hljs-number">2000</span>);  &#125;))  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs))  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs));</code></pre><p>4.</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;  res(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">123</span>));&#125;)  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs));</code></pre><p>5.</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;  rej(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">123</span>));&#125;)  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs));</code></pre><p>6.</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res(<span class="hljs-built_in">Promise</span>.resolve())).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>));<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">Promise</span>.resolve()).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>));</code></pre><p>7.</p><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">5</span>);  &#125;)  .then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(r);  &#125;);<span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);  &#125;);</code></pre><p>可以自己尝试思考再去控制台尝试，如果回答不上就应该往下看啦</p><h2 id="Promise-规范"><a href="#Promise-规范" class="headerlink" title="Promise 规范"></a>Promise 规范</h2><p>关于 Promise 的规范最早是由 commonjs 社区提出，毕竟多人接收的就是<a href="http://wiki.commonjs.org/wiki/Promises/A">Promise/A</a>，后面因规范较为简单所以在这基础上提出了<a href="https://promisesaplus.com/#point-27">Promise/A+</a>，这也是业界和 ES6 使用的标准，而 ES6 在这标准上还新增了 Promise.resolve、Promise.reject、Promise.all、Promise.race、Promise.prototype.catch、Promise.allSettled、Promise.prototype.finally 等方法。</p><p>而测试是否符合 Promise/A+标准的可以使用<a href="https://github.com/promises-aplus/promises-tests">promises-aplus-tests</a>库来测试，使用方法为在自己实现的 MyPromise 文件中加入如下代码导出</p><pre><code class="hljs javascript"><span class="hljs-comment">// MyPromise.js</span>MyPromise.defer = MyPromise.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> dfd = &#123;&#125;;  dfd.promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    dfd.resolve = resolve;    dfd.reject = reject;  &#125;);  <span class="hljs-keyword">return</span> dfd;&#125;;<span class="hljs-built_in">module</span>.exports = MyPromise;</code></pre><p>然后可以安装并在文件目录内运行</p><pre><code class="hljs bash">npm install -g promises-aplus-testspromises-aplus-tests MyPromise.js</code></pre><h2 id="微任务创建器"><a href="#微任务创建器" class="headerlink" title="微任务创建器"></a>微任务创建器</h2><p>我们都知道 Promise 的 then 创建的是异步任务（microtask），而我们需要实现 Promise 的话当然不能用他来创建，网上各种实现可能基本都是 setTimeout，这个是将任务推入下一宏任务（macrotask）中。所以我们需要一个微任务创建器，这时候就需要用到几个 api 了：一个是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask">queueMicrotask</a>，还有<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a>，这两个都是可以将回调函数推入微任务队列的，然后我们可以先封装一个降级方案：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 判断是否函数</span><span class="hljs-keyword">const</span> isFunction = <span class="hljs-function"><span class="hljs-params">target</span> =&gt;</span> <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span>;<span class="hljs-comment">// 判断是否原生方法</span><span class="hljs-keyword">const</span> isNativeFunction = <span class="hljs-function"><span class="hljs-params">Ctor</span> =&gt;</span>  isFunction(Ctor) &amp;&amp; <span class="hljs-regexp">/native code/</span>.test(Ctor.toString());<span class="hljs-comment">// 推入微任务队列</span><span class="hljs-keyword">const</span> nextTaskQueue = <span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (    <span class="hljs-keyword">typeof</span> queueMicrotask !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp;    isNativeFunction(queueMicrotask)  ) &#123;    queueMicrotask(cb);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (    <span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp;    (isNativeFunction(MutationObserver) ||      MutationObserver.toString() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span>)  ) &#123;    <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(cb);    <span class="hljs-keyword">const</span> node = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&#x27;1&#x27;</span>);    observer.observe(node, &#123;      characterData: <span class="hljs-literal">true</span>,    &#125;);    node.data = <span class="hljs-string">&#x27;2&#x27;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> process !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isFunction(process.nextTick)) &#123;    process.nextTick(cb);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      cb();    &#125;, <span class="hljs-number">0</span>);  &#125;&#125;;</code></pre><p>如此，后面我们需要创建异步 tick 就可以使用这个<code>nextTaskQueue</code>。</p><h2 id="Promise-结构"><a href="#Promise-结构" class="headerlink" title="Promise 结构"></a>Promise 结构</h2><p>可以从日常使用 Promise 中了解到，Promise 需要 new 出实例，并且传入回调函数，而回调函数接收两个参数（resolve、reject），回调函数会立刻执行。返回的 Promise 实例中可调用 then 或者 catch 接收完成和错误。</p><p>Promise 拥有三种状态分别为<code>pending</code>等待中、<code>fulfilled</code>已完成、<code>rejected</code>已拒绝，并且初始为等待中，且如果更改了状态则无法再更改。</p><p>而<code>Promise.prototype.then</code>可以接收两个参数，分别是<code>onFulfilled</code>和<code>onRejected</code>回调函数，<code>Promise.prototype.catch</code>只能接收<code>onRejected</code>。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> STATUS = &#123;  PENDING: <span class="hljs-string">&#x27;PENDING&#x27;</span>, <span class="hljs-comment">// 等待中</span>  FULFILLED: <span class="hljs-string">&#x27;FULFILLED&#x27;</span>, <span class="hljs-comment">// 已完成</span>  REJECTED: <span class="hljs-string">&#x27;REJECTED&#x27;</span>, <span class="hljs-comment">// 已拒绝</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;  status = STATUS.PENDING; <span class="hljs-comment">// 初始化状态为等待中</span>  <span class="hljs-keyword">constructor</span>(executor) &#123;    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;&#125;;    <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;&#125;;    <span class="hljs-keyword">try</span> &#123;      executor(resolve, reject); <span class="hljs-comment">// 实例化即刻执行</span>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;      reject(err); <span class="hljs-comment">// 发生错误则被捕捉</span>    &#125;  &#125;  then(onFulfiled, onRejected) &#123;&#125;&#125;</code></pre><p>我们发现 Promise 对象在每次使用 then 或者 catch 后获取的值都会一致不变，而且在完成前多个 then 或者 catch 监听会在完成、拒绝后一个个调用，所以知道这里会保存值和错误以及维护一个完成和拒绝的队列</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> STATUS = &#123;  PENDING: <span class="hljs-string">&#x27;PENDING&#x27;</span>, <span class="hljs-comment">// 等待中</span>  FULFILLED: <span class="hljs-string">&#x27;FULFILLED&#x27;</span>, <span class="hljs-comment">// 已完成</span>  REJECTED: <span class="hljs-string">&#x27;REJECTED&#x27;</span>, <span class="hljs-comment">// 已拒绝</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;  _resolveQueue = []; <span class="hljs-comment">// 完成回调队列</span>  _rejectQueue = []; <span class="hljs-comment">// 拒绝回调队列</span>  result = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 完成的值</span>  state = STATUS.PENDING; <span class="hljs-comment">// 初始化状态为等待中</span>  <span class="hljs-keyword">constructor</span>(executor) &#123;    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;      <span class="hljs-comment">// 只有在等待中的状态才可以resolve</span>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === STATUS.PENDING) &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-comment">// 如果传入resolve内的为thenable对象，则以它的状态为准</span>          resolvePromise(<span class="hljs-built_in">this</span>, value, realResolve, reject);        &#125; <span class="hljs-keyword">catch</span> (err) &#123;          reject(err);        &#125;      &#125;    &#125;;    <span class="hljs-keyword">const</span> realResolve = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;      <span class="hljs-comment">// 只有在等待中的状态才可以resolve</span>      <span class="hljs-built_in">this</span>.state = STATUS.FULFILLED; <span class="hljs-comment">// 修改状态</span>      <span class="hljs-built_in">this</span>.result = value; <span class="hljs-comment">// 保存值</span>      <span class="hljs-comment">// 真正的创建了微任务的封装</span>      nextTaskQueue(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._resolveQueue.length) &#123;          <span class="hljs-keyword">const</span> callback = <span class="hljs-built_in">this</span>._resolveQueue.shift();          callback(value); <span class="hljs-comment">// 一个个执行</span>        &#125;      &#125;);    &#125;;    <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;      <span class="hljs-comment">// 与resolve一致，只是修改的状态和保存的理由以及执行的队列不一样</span>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === STATUS.PENDING) &#123;        <span class="hljs-built_in">this</span>.state = STATUS.REJECTED;        <span class="hljs-built_in">this</span>.result = reason;        nextTaskQueue(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._rejectQueue.length) &#123;            <span class="hljs-keyword">const</span> callback = <span class="hljs-built_in">this</span>._rejectQueue.shift(); <span class="hljs-comment">// 获取拒绝回调队列</span>            callback(reason);          &#125;        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      executor(resolve, reject); <span class="hljs-comment">// 实例化即刻执行</span>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;      reject(err); <span class="hljs-comment">// 发生错误则被捕捉</span>    &#125;  &#125;  then(onFulfiled, onRejected) &#123;&#125;&#125;</code></pre><p>到这里，构造函数已经差不多了，剩下的开始实现<code>then</code>方法。</p><p>我们知道，then 后面可以链式调用 then，并且<strong>then 获取的值为上一个 then 返回的新 Promise 对象中的值</strong>，很多人误认为链式调用获取的是链式的头的 Promise，其实不然，Promise 每个 then 都会创建一个新 Promise，所以你下一个 then 跟最前面的 Promise 不一定有关系。</p><p>而且，如果 then 中传入的不是函数，则会直接传出，直到被传入函数的 then 捕捉。</p><p>然后，在调用 then 时，Promise 对象可能为三种状态，但是即使是已完成或已拒绝，也不会立刻执行，而是被推入微任务队列中。</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;  then(onFulfilled, onRejected) &#123;    onFulfilled =      <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value; <span class="hljs-comment">// 如果不是函数则传递给下一个</span>    onRejected =      <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span>        ? onRejected        : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;            <span class="hljs-keyword">throw</span> reason;          &#125;;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === STATUS.FULFILLED) &#123;        nextTaskQueue(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// 即使Promise对象是已完成，也不会立刻执行</span>          <span class="hljs-keyword">const</span> result = onFulfilled(<span class="hljs-built_in">this</span>.result); <span class="hljs-comment">// 传入的回调可以获取值</span>          resolve(result);        &#125;);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === STATUS.REJECTED) &#123;        nextTaskQueue(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// 即使Promise对象是已拒绝，也不会立刻执行</span>          <span class="hljs-keyword">const</span> result = onRejected(<span class="hljs-built_in">this</span>.result); <span class="hljs-comment">// 传入的回调可以拒绝理由</span>          reject(result);        &#125;);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === STATUS.PENDING) &#123;        <span class="hljs-comment">// 如果是等待中，则分别推入回调队列中</span>        <span class="hljs-built_in">this</span>._resolveQueue.push(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">const</span> result = onFulfilled(<span class="hljs-built_in">this</span>.result);          resolve(result);        &#125;);        <span class="hljs-built_in">this</span>._rejectQueue.push(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">const</span> result = onRejected(<span class="hljs-built_in">this</span>.result);          reject(result);        &#125;);      &#125;    &#125;);  &#125;&#125;</code></pre><p>到这里为止，基本差不多了，然而并没有这么简单。回调函数可能是任何值，包括返回了一个 Promise 对象，这种情况需要以返回的 Promise 为准。并且如果是这种情况，后面 then 会被延迟两个 tick 执行，具体实现可以参考 V8 引擎对<a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/9.0-lkgr/src/builtins/promise-resolve.tq#88">ResolvePromise</a>和<a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/9.0-lkgr/src/builtins/promise-jobs.tq">PromiseResolveThenableJob</a>的实现，这里不作深入讲解。</p><p>所以这里可以封装出一个方法专门处理 Promise 以及其回调，以适配所有标准</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resolvePromise = <span class="hljs-function">(<span class="hljs-params">newPromise, result, resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 规范2.3.1，避免循环引用</span><span class="hljs-comment">   * e.g. const p = MyPromise.resolve().then(() =&gt; p);</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">if</span> (newPromise === result) &#123;    <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Chaining cycle detected for promise&#x27;</span>));  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 用来判断resolvePormise是否已经执行过了，如果执行过resolve或者reject就不要再往下走resolve或者reject</span><span class="hljs-comment">   * 在一些返回thenable对象中，连续调用多次回调的情况</span><span class="hljs-comment">   * e.g. then(() =&gt; &#123;</span><span class="hljs-comment">   *        return &#123;</span><span class="hljs-comment">   *          then(resolve)&#123;</span><span class="hljs-comment">   *            resolve(1);</span><span class="hljs-comment">   *            resolve(2);</span><span class="hljs-comment">   *          &#125;</span><span class="hljs-comment">   *        &#125;</span><span class="hljs-comment">   *      &#125;)</span><span class="hljs-comment">   * 网上大部分的都没说这个情况到底是什么</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;  <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;object&#x27;</span> || isFunction(result))) &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">const</span> &#123; then &#125; = result;      <span class="hljs-keyword">if</span> (isFunction(then)) &#123;        <span class="hljs-comment">// 规范2.3.3.3 如果result是个thenable对象，则调用其then方法，当他是Promise</span>        then.call(          result,          value =&gt; &#123;            <span class="hljs-keyword">if</span> (!called) &#123;              called = <span class="hljs-literal">true</span>;              <span class="hljs-comment">// 现代浏览器中，如果then返回是thenable对象则会延迟一次执行，而本身的then又会延迟，所以其实是两次</span>              nextTaskQueue(<span class="hljs-function">() =&gt;</span> &#123;                resolvePromise(newPromise, value, resolve, reject); <span class="hljs-comment">// 这里需要递归取值，直到不是Promise为止</span>              &#125;);            &#125;          &#125;,          reason =&gt; &#123;            <span class="hljs-keyword">if</span> (!called) &#123;              called = <span class="hljs-literal">true</span>;              nextTaskQueue(<span class="hljs-function">() =&gt;</span> &#123;                reject(reason);              &#125;);            &#125;          &#125;        );      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 规范2.3.3.4 如果 result不是thenable对象，则返回fulfilled</span>        resolve(result);      &#125;    &#125; <span class="hljs-keyword">catch</span> (err) &#123;      <span class="hljs-keyword">if</span> (!called) &#123;        called = <span class="hljs-literal">true</span>;        reject(err);      &#125;    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    resolve(result);  &#125;&#125;;</code></pre><p>所以 then 方法改为</p><pre><code class="hljs javascript">then(onFulfilled, onRejected) &#123;  onFulfilled =    <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value; <span class="hljs-comment">// 如果不是函数则传递给下一个</span>  onRejected =    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span>      ? onRejected      : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;          <span class="hljs-keyword">throw</span> reason;        &#125;;  <span class="hljs-keyword">let</span> newPromise;  <span class="hljs-keyword">return</span> (newPromise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === STATUS.FULFILLED) &#123;      nextTaskQueue(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 即使Promise对象是已完成，也不会立刻执行</span>        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">const</span> result = onFulfilled(<span class="hljs-built_in">this</span>.result); <span class="hljs-comment">// 传入的回调可以获取值</span>          resolvePromise(newPromise, result, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (err) &#123;          reject(err);        &#125;      &#125;);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === STATUS.REJECTED) &#123;      nextTaskQueue(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 即使Promise对象是已拒绝，也不会立刻执行</span>        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">const</span> result = onRejected(<span class="hljs-built_in">this</span>.result); <span class="hljs-comment">// 传入的回调可以拒绝理由</span>          resolvePromise(newPromise, result, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (err) &#123;          reject(err);        &#125;      &#125;);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === STATUS.PENDING) &#123;      <span class="hljs-comment">// 如果是等待中，则分别推入回调队列中</span>      <span class="hljs-built_in">this</span>._resolveQueue.push(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">const</span> result = onFulfilled(<span class="hljs-built_in">this</span>.result);          resolvePromise(newPromise, result, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (err) &#123;          reject(err);        &#125;      &#125;);      <span class="hljs-built_in">this</span>._rejectQueue.push(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">const</span> result = onRejected(<span class="hljs-built_in">this</span>.result);          resolvePromise(newPromise, result, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (err) &#123;          reject(err);        &#125;      &#125;);    &#125;  &#125;));&#125;</code></pre><p>最后加入上面说的测试导出，跑一次测试即可<br><img src="https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/promise.png" alt="测试结果"><br>827 个测试项全通过~！</p><hr><p>剩下的可以增加一些 api 实现和判断即可。</p><p>但是<strong>要注意</strong>的是，静态方法包括 all、race、allSettled、any 等，传入的是任意<strong>可迭代对象</strong>，包括字符串等，如果传入的迭代对象中的子元素如果非 Promise 对象，则直接返回，而即使是非 Promise 对象，也是需要推入微任务在下一 tick 执行（很多实现忽略了这些）。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>因为个人在网上看了很多类似的，但是并没有很完整的解释细节，例如 called 是做什么的。<br>所以自己总结了一下。</p><p>因为发现很多同学觉得 Promise 就是用来封装读接口的通讯方法的，这里表示 Promise<strong>不仅仅可以做读接口封装，还可以做很多有趣的封装</strong></p><p>例如：</p><ul><li>wait 等待几秒后执行</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> wait = <span class="hljs-function"><span class="hljs-params">time</span> =&gt;</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(timer), time);  &#125;);(<span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">2000</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;)();<span class="hljs-comment">// print 1</span><span class="hljs-comment">// wait for 2 seconds</span><span class="hljs-comment">// print 2</span></code></pre><ul><li>早期的小程序 api promise 化，因为本人 16 年开始接触小程序，那时候小程序全是 success 和 fail 回调，用起来很头疼（现在全支持 thenable 调用了），所以做了个 promisify 函数。</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promisify =  wxapi =&gt;  (options, ...args) =&gt;    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>      wxapi.apply(<span class="hljs-literal">null</span>, [        &#123;          ...options,          success: resolve,          fail: <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(err);            reject(err);          &#125;,        &#125;,        ...args,      ])    );(<span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-keyword">await</span> promisify(wx.login)();  <span class="hljs-keyword">await</span> promisify(wx.checkSession)();  <span class="hljs-comment">// session有效！</span>&#125;)();<span class="hljs-keyword">const</span> loading = <span class="hljs-function">(<span class="hljs-params">title = <span class="hljs-string">&#x27;加载中..&#x27;</span></span>) =&gt;</span> &#123;  promisify(wx.showLoading)(&#123;    title: i18n.getLocaleByName(title),    mask: <span class="hljs-literal">true</span>,  &#125;);&#125;;</code></pre><hr><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在了解了源码后，其实可以延伸出一些 Promise 执行顺序的问题</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;  res();  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 代码块1</span>&#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 代码块2</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      res();      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);    &#125;)      .then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 代码块3</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;          res();          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);        &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// 代码块4</span>          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>);        &#125;);      &#125;)      .then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 代码块5</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">9</span>);        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;          res();          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">10</span>);        &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// 代码块6</span>          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">12</span>);        &#125;);      &#125;);    <span class="hljs-built_in">Promise</span>.resolve()      .then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 代码块7</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);      &#125;)      .then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 代码块8</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">11</span>);      &#125;);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 代码块9</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>);  &#125;);</code></pre><p>以上可以解释一下执行顺序</p><ul><li>tick1、<strong>代码块 1</strong>先执行，resolve 了，将<strong>代码块 2</strong>推入 nextTick，<code>打印1</code></li><li>tick2、<strong>代码块 2</strong>执行，<code>打印2</code>，创建 Promise，resolve 了所以将<strong>代码块 3</strong>推入 nextTick，<code>打印3</code>；往下走，Promise.resolve 创建了一个 fulfilled 的 Promise，所以<strong>代码块 7</strong>推入 nextTick，执行完毕<strong>代码块 2</strong>，所以<strong>代码块 9</strong>被推入 nextTick</li><li>tick3、<strong>代码块 3</strong>执行，<code>打印4</code>，创建 Promise，resolve 了将<strong>代码块 4</strong>推入 nextTick，<code>打印5</code>，执行完 then 所以将下一个 then 的<strong>代码块 5</strong>推入 nextTick；然后<strong>代码块 7</strong>执行，<code>打印6</code>，执行完所以将下一个 then 的<strong>代码块 8</strong>推入 nextTick；执行<strong>代码块 9</strong>，<code>打印7</code></li><li>tick4、<strong>代码块 4</strong>执行，<code>打印8</code>；<strong>代码块 5</strong>执行，<code>打印9</code>，创建新 Promise，resolve 了所以将<strong>代码块 6</strong>推入 nextTick，<code>打印10</code>；<strong>代码块 8</strong>执行，<code>打印11</code></li><li>tick5、<strong>代码块 6</strong>执行，<code>打印12</code></li></ul><hr><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.reject(  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      rej(<span class="hljs-number">133222</span>);      res(<span class="hljs-number">444</span>);    &#125;, <span class="hljs-number">2000</span>);  &#125;))  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs))  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs));</code></pre><p>这里很容易理解，会<strong>立刻</strong>执行第二个 catch 和第三个 then，打印 pending 中的 Promise 对象和 undefined，因为 Promise.reject 会创建一个已 rejected 的 Promise 对象，value 为传入的值。</p><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      rej(<span class="hljs-number">133222</span>);      res(<span class="hljs-number">444</span>);    &#125;, <span class="hljs-number">2000</span>);  &#125;))  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs))  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs));</code></pre><p>但是这里就不一样了，会<strong>等待 2 秒</strong>后，但是还是第二个 catch 和第三个 then。因为 Promise.resolve 如果传入的是 <code>thenable</code> 对象，则返回以此为准。</p><hr><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;  res(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">123</span>));&#125;)  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs));</code></pre><p>这里会以为调用 then，因为调用了内部的 resolve 方法，其实不然，这里会走 catch 回调并且打印 catch 和 123，因为 resolve 内如果传入 <code>thenable</code> 对象则会一次为准</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;  rej(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">123</span>));&#125;)  .then(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>, rs))  .catch(<span class="hljs-function"><span class="hljs-params">rs</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;catch&#x27;</span>, rs));</code></pre><p>而 reject 则不会。</p><hr><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res(<span class="hljs-built_in">Promise</span>.resolve())).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>));<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">Promise</span>.resolve()).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>));</code></pre><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">5</span>);  &#125;)  .then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(r);  &#125;);<span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);  &#125;);</code></pre><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> &#123;      then(r) &#123;        r(<span class="hljs-number">5</span>);      &#125;,    &#125;;  &#125;)  .then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(r);  &#125;);<span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);  &#125;)  .then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);  &#125;);</code></pre><p>这两个可以一块说，大部分网上的例子都没实现这块的逻辑，也是 Promise 的一个需要注意的细节：<strong>就是 resolve、then 传入的回调函数的返回，如果是 Promise 对象，则会延迟两个 tick</strong>。</p><p>为什么呢，这块当然涉及到 v8 实现的源码，不说这么复杂简单化来说的话就是，Promise 会先把 then 执行一次，这里会有一个 tick（如果是 thenable 对象则不会，因为并非原生的then），执行这个 then 时传入的回调会包含另一个 tick 的延迟。</p><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>下面贴出全代码实现，包含了</p><ul><li><input checked="" disabled="" type="checkbox"> Promise/A+规范实现</li><li><input checked="" disabled="" type="checkbox"> 所有目前（ES2021）的 Promise 实例方法（finally）、静态方法（any、allSettled）等的实现</li><li><input checked="" disabled="" type="checkbox"> 将异步任务正确推入微任务队列</li><li><input checked="" disabled="" type="checkbox"> then 传入的回调函数返回 Promise 对象，延迟两个 tick</li><li><input checked="" disabled="" type="checkbox"> 构造函数的参数 executor 中 resolve 入参传入为 Promise 对象也会延迟两个 tick</li><li><input checked="" disabled="" type="checkbox"> Promise.resolve 传入 Promise 对象时会直接将其返回出去，Promise.reject 则不然</li><li><input checked="" disabled="" type="checkbox"> Promise 各种静态方法（all、race、any、allsettled）传入的是可迭代对象而非数组</li><li><input checked="" disabled="" type="checkbox"> Promise 各种静态方法（all、race、any、allsettled）传入的可迭代对象成员如果不是 Promise 对象会直接返回，但是也是会进入下一微任务（很多实现都是直接 resolve 并没有延迟）</li></ul><h2 id="完整代码在这里"><a href="#完整代码在这里" class="headerlink" title="完整代码在这里"></a><strong><a href="https://github.com/ben-lau/blog/blob/master/assets/script/MyPromise.js">完整代码在这里</a></strong></h2>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端代码规范</title>
    <link href="/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <url>/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>很多人可能会疑惑，代码自己写的看的舒服不就得了，为什么一定要这样。是的，当你是一个人维护的时候确实是这样子，但是当多人协同开发的时候，代码规范就尤为重要，不仅仅会减少因为格式、风格不一致的代码合并记录，还能减少容易出现的 bug 和出问题的概率，更能提升自己的编码水平；当你能完全掌控自己代码的时候就会发现，有规范有约定的代码是如何优雅和易调试。所以即使是单人维护开发的项目，也需要有代码规范约定，这种约定可能来自于业界的共识，也可能来自公司的规则，也可能是个人的理解。</p><p>虽然代码规范很多地方并不能用脚本或者人为强制控制，但是也希望各位能严格遵从，有问题可以提出并讨论，但是有规范的团队才是有战斗力的。保持自律，做个牛批的 programmer</p><hr><h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><p>代码一致性和最佳实践。通过代码风格的一致性，降低维护代码的成本以及改善多人协作的效率。同时遵守最佳实践，确保页面性能得到最佳优化和高效的代码。</p><h2 id="关于项目"><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h2><ol><li>项目文件命名应该全小写，以横杠隔开单词的形式，因为部分文件管理器不区分大小写</li><li>文件命名应该清晰易懂，最好包含该模块的功能和属性</li><li>如果一个模块文件夹内包含多个子模块，那默认导出模块文件应取名 <code>index</code></li></ol><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><code>原则：html 为前端的结构层，不应将样式层和逻辑层混写进入，减少没必要的多余空格，页面结构尽可能简单明了</code>。</p><ol><li>缩进使用 2 个空格。</li><li>所有标签都必须闭合，包括一些自闭合的标签。</li><li>使用双引号而不是单引号。</li><li>一行应最好不超过 80 个字符，如过长可以属性换行。</li><li>属性过多的（2 个或以上）可换行。</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name-input&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name-input&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入名字&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;10&quot;</span></span><span class="hljs-tag">/&gt;</span></code></pre><ol start="6"><li>注释可以为大型模块标注结构起始。</li></ol><pre><code class="hljs html"><span class="hljs-comment">&lt;!--卡片头部--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-header&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!--...--&gt;</span>  <span class="hljs-comment">&lt;!--大量结构--&gt;</span>  <span class="hljs-comment">&lt;!--...--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--卡片头部 END--&gt;</span></code></pre><ol start="7"><li>书写代码前应考虑结构复用性。</li></ol><details>  <summary>通用prettier代码风格配置</summary><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;printWidth&quot;</span>: <span class="hljs-number">80</span>,  <span class="hljs-attr">&quot;tabWidth&quot;</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">&quot;useTabs&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">&quot;semi&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">&quot;singleQuote&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">&quot;proseWrap&quot;</span>: <span class="hljs-string">&quot;preserve&quot;</span>,  <span class="hljs-attr">&quot;arrowParens&quot;</span>: <span class="hljs-string">&quot;avoid&quot;</span>,  <span class="hljs-attr">&quot;bracketSpacing&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">&quot;disableLanguages&quot;</span>: [<span class="hljs-string">&quot;vue&quot;</span>],  <span class="hljs-attr">&quot;endOfLine&quot;</span>: <span class="hljs-string">&quot;auto&quot;</span>,  <span class="hljs-attr">&quot;ignorePath&quot;</span>: <span class="hljs-string">&quot;.prettierignore&quot;</span>,  <span class="hljs-attr">&quot;jsxBracketSameLine&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">&quot;jsxSingleQuote&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">&quot;requireConfig&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">&quot;trailingComma&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>&#125;</code></pre></details><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol><li>类名使用小写字母，用横杠隔开单词。</li><li>按结构层和样式层分层的原则来说，应避免出现 html 标签选择器。</li><li>选择器应尽量简单，减少复杂嵌套。</li><li>省略 0 属性值后面的单位。</li><li>注释格式 <code>/* 这儿是注释 */</code>。</li><li>样式应该有一定顺序性，总结来说就是盒子属性、盒子样式、行内属性、行内样式、动画。</li></ol><details>  <summary>tips: 样式顺序 stylelint</summary><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  plugins: [<span class="hljs-string">&#x27;stylelint-order&#x27;</span>],  rules: &#123;    <span class="hljs-string">&#x27;property-no-unknown&#x27;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-string">&#x27;order/properties-order&#x27;</span>: [      &#123;        <span class="hljs-comment">// 重置</span>        properties: [<span class="hljs-string">&#x27;all&#x27;</span>],      &#125;,      &#123;        <span class="hljs-comment">// 显示类型</span>        properties: [<span class="hljs-string">&#x27;display&#x27;</span>, <span class="hljs-string">&#x27;box-sizing&#x27;</span>],      &#125;,      &#123;        <span class="hljs-comment">// flex布局样式</span>        properties: [          <span class="hljs-string">&#x27;flex&#x27;</span>,          <span class="hljs-string">&#x27;flex-basis&#x27;</span>,          <span class="hljs-string">&#x27;flex-direction&#x27;</span>,          <span class="hljs-string">&#x27;flex-flow&#x27;</span>,          <span class="hljs-string">&#x27;flex-grow&#x27;</span>,          <span class="hljs-string">&#x27;flex-shrink&#x27;</span>,          <span class="hljs-string">&#x27;flex-wrap&#x27;</span>,        ],      &#125;,      &#123;        <span class="hljs-comment">// grid布局样式</span>        properties: [          <span class="hljs-string">&#x27;grid&#x27;</span>,          <span class="hljs-string">&#x27;grid-area&#x27;</span>,          <span class="hljs-string">&#x27;grid-template&#x27;</span>,          <span class="hljs-string">&#x27;grid-template-areas&#x27;</span>,          <span class="hljs-string">&#x27;grid-template-rows&#x27;</span>,          <span class="hljs-string">&#x27;grid-template-columns&#x27;</span>,          <span class="hljs-string">&#x27;grid-row&#x27;</span>,          <span class="hljs-string">&#x27;grid-row-start&#x27;</span>,          <span class="hljs-string">&#x27;grid-row-end&#x27;</span>,          <span class="hljs-string">&#x27;grid-column&#x27;</span>,          <span class="hljs-string">&#x27;grid-column-start&#x27;</span>,          <span class="hljs-string">&#x27;grid-column-end&#x27;</span>,          <span class="hljs-string">&#x27;grid-auto-rows&#x27;</span>,          <span class="hljs-string">&#x27;grid-auto-columns&#x27;</span>,          <span class="hljs-string">&#x27;grid-auto-flow&#x27;</span>,          <span class="hljs-string">&#x27;grid-gap&#x27;</span>,          <span class="hljs-string">&#x27;grid-row-gap&#x27;</span>,          <span class="hljs-string">&#x27;grid-column-gap&#x27;</span>,        ],      &#125;,      &#123;        <span class="hljs-comment">// 列</span>        properties: [<span class="hljs-string">&#x27;align-content&#x27;</span>, <span class="hljs-string">&#x27;align-items&#x27;</span>, <span class="hljs-string">&#x27;align-self&#x27;</span>],      &#125;,      &#123;        <span class="hljs-comment">// 行</span>        properties: [<span class="hljs-string">&#x27;justify-content&#x27;</span>, <span class="hljs-string">&#x27;justify-items&#x27;</span>, <span class="hljs-string">&#x27;justify-self&#x27;</span>],      &#125;,      &#123;        <span class="hljs-comment">// 空隙</span>        properties: [<span class="hljs-string">&#x27;gap&#x27;</span>, <span class="hljs-string">&#x27;row-gap&#x27;</span>, <span class="hljs-string">&#x27;column-gap&#x27;</span>],      &#125;,      &#123;        <span class="hljs-comment">// 位置</span>        properties: [<span class="hljs-string">&#x27;position&#x27;</span>, <span class="hljs-string">&#x27;top&#x27;</span>, <span class="hljs-string">&#x27;right&#x27;</span>, <span class="hljs-string">&#x27;bottom&#x27;</span>, <span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-string">&#x27;z-index&#x27;</span>],      &#125;,      &#123;        <span class="hljs-comment">// 顺序</span>        properties: [<span class="hljs-string">&#x27;order&#x27;</span>],      &#125;,      &#123;        <span class="hljs-comment">// 盒子模型</span>        properties: [          <span class="hljs-string">&#x27;float&#x27;</span>,          <span class="hljs-string">&#x27;width&#x27;</span>,          <span class="hljs-string">&#x27;min-width&#x27;</span>,          <span class="hljs-string">&#x27;max-width&#x27;</span>,          <span class="hljs-string">&#x27;height&#x27;</span>,          <span class="hljs-string">&#x27;min-height&#x27;</span>,          <span class="hljs-string">&#x27;max-height&#x27;</span>,          <span class="hljs-string">&#x27;padding&#x27;</span>,          <span class="hljs-string">&#x27;padding-top&#x27;</span>,          <span class="hljs-string">&#x27;padding-right&#x27;</span>,          <span class="hljs-string">&#x27;padding-bottom&#x27;</span>,          <span class="hljs-string">&#x27;padding-left&#x27;</span>,          <span class="hljs-string">&#x27;margin&#x27;</span>,          <span class="hljs-string">&#x27;margin-top&#x27;</span>,          <span class="hljs-string">&#x27;margin-right&#x27;</span>,          <span class="hljs-string">&#x27;margin-bottom&#x27;</span>,          <span class="hljs-string">&#x27;margin-left&#x27;</span>,          <span class="hljs-string">&#x27;overflow&#x27;</span>,          <span class="hljs-string">&#x27;overflow-x&#x27;</span>,          <span class="hljs-string">&#x27;overflow-y&#x27;</span>,          <span class="hljs-string">&#x27;-webkit-overflow-scrolling&#x27;</span>,          <span class="hljs-string">&#x27;-ms-overflow-x&#x27;</span>,          <span class="hljs-string">&#x27;-ms-overflow-y&#x27;</span>,          <span class="hljs-string">&#x27;-ms-overflow-style&#x27;</span>,          <span class="hljs-string">&#x27;clip&#x27;</span>,          <span class="hljs-string">&#x27;clear&#x27;</span>,        ],      &#125;,      &#123;        <span class="hljs-comment">// 盒子样式</span>        properties: [          <span class="hljs-string">&#x27;background&#x27;</span>,          <span class="hljs-string">&#x27;background-color&#x27;</span>,          <span class="hljs-string">&#x27;background-image&#x27;</span>,          <span class="hljs-string">&quot;-ms-filter:\\&#x27;progid:DXImageTransform.Microsoft.gradient&quot;</span>,          <span class="hljs-string">&#x27;filter:progid:DXImageTransform.Microsoft.gradient&#x27;</span>,          <span class="hljs-string">&#x27;filter:progid:DXImageTransform.Microsoft.AlphaImageLoader&#x27;</span>,          <span class="hljs-string">&#x27;filter&#x27;</span>,          <span class="hljs-string">&#x27;background-repeat&#x27;</span>,          <span class="hljs-string">&#x27;background-attachment&#x27;</span>,          <span class="hljs-string">&#x27;background-position&#x27;</span>,          <span class="hljs-string">&#x27;background-position-x&#x27;</span>,          <span class="hljs-string">&#x27;background-position-y&#x27;</span>,          <span class="hljs-string">&#x27;background-clip&#x27;</span>,          <span class="hljs-string">&#x27;background-origin&#x27;</span>,          <span class="hljs-string">&#x27;background-size&#x27;</span>,          <span class="hljs-string">&#x27;background-blend-mode&#x27;</span>,          <span class="hljs-string">&#x27;isolation&#x27;</span>,          <span class="hljs-string">&#x27;border&#x27;</span>,          <span class="hljs-string">&#x27;border-color&#x27;</span>,          <span class="hljs-string">&#x27;border-style&#x27;</span>,          <span class="hljs-string">&#x27;border-width&#x27;</span>,          <span class="hljs-string">&#x27;border-top&#x27;</span>,          <span class="hljs-string">&#x27;border-top-color&#x27;</span>,          <span class="hljs-string">&#x27;border-top-style&#x27;</span>,          <span class="hljs-string">&#x27;border-top-width&#x27;</span>,          <span class="hljs-string">&#x27;border-right&#x27;</span>,          <span class="hljs-string">&#x27;border-right-color&#x27;</span>,          <span class="hljs-string">&#x27;border-right-style&#x27;</span>,          <span class="hljs-string">&#x27;border-right-width&#x27;</span>,          <span class="hljs-string">&#x27;border-bottom&#x27;</span>,          <span class="hljs-string">&#x27;border-bottom-color&#x27;</span>,          <span class="hljs-string">&#x27;border-bottom-style&#x27;</span>,          <span class="hljs-string">&#x27;border-bottom-width&#x27;</span>,          <span class="hljs-string">&#x27;border-left&#x27;</span>,          <span class="hljs-string">&#x27;border-left-color&#x27;</span>,          <span class="hljs-string">&#x27;border-left-style&#x27;</span>,          <span class="hljs-string">&#x27;border-left-width&#x27;</span>,          <span class="hljs-string">&#x27;border-radius&#x27;</span>,          <span class="hljs-string">&#x27;border-top-left-radius&#x27;</span>,          <span class="hljs-string">&#x27;border-top-right-radius&#x27;</span>,          <span class="hljs-string">&#x27;border-bottom-right-radius&#x27;</span>,          <span class="hljs-string">&#x27;border-bottom-left-radius&#x27;</span>,          <span class="hljs-string">&#x27;border-image&#x27;</span>,          <span class="hljs-string">&#x27;border-image-source&#x27;</span>,          <span class="hljs-string">&#x27;border-image-slice&#x27;</span>,          <span class="hljs-string">&#x27;border-image-width&#x27;</span>,          <span class="hljs-string">&#x27;border-image-outset&#x27;</span>,          <span class="hljs-string">&#x27;border-image-repeat&#x27;</span>,          <span class="hljs-string">&#x27;outline&#x27;</span>,          <span class="hljs-string">&#x27;outline-width&#x27;</span>,          <span class="hljs-string">&#x27;outline-style&#x27;</span>,          <span class="hljs-string">&#x27;outline-color&#x27;</span>,          <span class="hljs-string">&#x27;outline-offset&#x27;</span>,          <span class="hljs-string">&#x27;box-shadow&#x27;</span>,          <span class="hljs-string">&#x27;mix-blend-mode&#x27;</span>,          <span class="hljs-string">&#x27;filter:progid:DXImageTransform.Microsoft.Alpha(Opacity&#x27;</span>,          <span class="hljs-string">&quot;-ms-filter:\\&#x27;progid:DXImageTransform.Microsoft.Alpha&quot;</span>,          <span class="hljs-string">&#x27;opacity&#x27;</span>,          <span class="hljs-string">&#x27;-ms-interpolation-mode&#x27;</span>,        ],      &#125;,      &#123;        <span class="hljs-comment">// 行内样式</span>        properties: [          <span class="hljs-string">&#x27;font&#x27;</span>,          <span class="hljs-string">&#x27;font-family&#x27;</span>,          <span class="hljs-string">&#x27;font-size&#x27;</span>,          <span class="hljs-string">&#x27;font-style&#x27;</span>,          <span class="hljs-string">&#x27;font-weight&#x27;</span>,          <span class="hljs-string">&#x27;font-variant&#x27;</span>,          <span class="hljs-string">&#x27;font-size-adjust&#x27;</span>,          <span class="hljs-string">&#x27;font-stretch&#x27;</span>,          <span class="hljs-string">&#x27;font-effect&#x27;</span>,          <span class="hljs-string">&#x27;font-emphasize&#x27;</span>,          <span class="hljs-string">&#x27;font-emphasize-position&#x27;</span>,          <span class="hljs-string">&#x27;font-emphasize-style&#x27;</span>,          <span class="hljs-string">&#x27;-webkit-font-smoothing&#x27;</span>,          <span class="hljs-string">&#x27;-moz-osx-font-smoothing&#x27;</span>,          <span class="hljs-string">&#x27;font-smooth&#x27;</span>,          <span class="hljs-string">&#x27;hyphens&#x27;</span>,          <span class="hljs-string">&#x27;line-height&#x27;</span>,          <span class="hljs-string">&#x27;color&#x27;</span>,          <span class="hljs-string">&#x27;text-align&#x27;</span>,          <span class="hljs-string">&#x27;text-align-last&#x27;</span>,          <span class="hljs-string">&#x27;text-emphasis&#x27;</span>,          <span class="hljs-string">&#x27;text-emphasis-color&#x27;</span>,          <span class="hljs-string">&#x27;text-emphasis-style&#x27;</span>,          <span class="hljs-string">&#x27;text-emphasis-position&#x27;</span>,          <span class="hljs-string">&#x27;text-decoration&#x27;</span>,          <span class="hljs-string">&#x27;text-indent&#x27;</span>,          <span class="hljs-string">&#x27;text-justify&#x27;</span>,          <span class="hljs-string">&#x27;text-outline&#x27;</span>,          <span class="hljs-string">&#x27;-ms-text-overflow&#x27;</span>,          <span class="hljs-string">&#x27;text-overflow&#x27;</span>,          <span class="hljs-string">&#x27;text-overflow-ellipsis&#x27;</span>,          <span class="hljs-string">&#x27;text-overflow-mode&#x27;</span>,          <span class="hljs-string">&#x27;text-shadow&#x27;</span>,          <span class="hljs-string">&#x27;text-transform&#x27;</span>,          <span class="hljs-string">&#x27;text-wrap&#x27;</span>,          <span class="hljs-string">&#x27;-webkit-text-size-adjust&#x27;</span>,          <span class="hljs-string">&#x27;-ms-text-size-adjust&#x27;</span>,          <span class="hljs-string">&#x27;letter-spacing&#x27;</span>,          <span class="hljs-string">&#x27;word-break&#x27;</span>,          <span class="hljs-string">&#x27;word-spacing&#x27;</span>,          <span class="hljs-string">&#x27;word-wrap&#x27;</span>,          <span class="hljs-string">&#x27;overflow-wrap&#x27;</span>,          <span class="hljs-string">&#x27;tab-size&#x27;</span>,          <span class="hljs-string">&#x27;white-space&#x27;</span>,          <span class="hljs-string">&#x27;vertical-align&#x27;</span>,          <span class="hljs-string">&#x27;list-style&#x27;</span>,          <span class="hljs-string">&#x27;list-style-position&#x27;</span>,          <span class="hljs-string">&#x27;list-style-type&#x27;</span>,          <span class="hljs-string">&#x27;list-style-image&#x27;</span>,        ],      &#125;,      &#123;        <span class="hljs-comment">// 可访问性和互动性</span>        properties: [          <span class="hljs-string">&#x27;pointer-events&#x27;</span>,          <span class="hljs-string">&#x27;-ms-touch-action&#x27;</span>,          <span class="hljs-string">&#x27;touch-action&#x27;</span>,          <span class="hljs-string">&#x27;cursor&#x27;</span>,          <span class="hljs-string">&#x27;visibility&#x27;</span>,          <span class="hljs-string">&#x27;zoom&#x27;</span>,          <span class="hljs-string">&#x27;table-layout&#x27;</span>,          <span class="hljs-string">&#x27;empty-cells&#x27;</span>,          <span class="hljs-string">&#x27;caption-side&#x27;</span>,          <span class="hljs-string">&#x27;border-spacing&#x27;</span>,          <span class="hljs-string">&#x27;border-collapse&#x27;</span>,          <span class="hljs-string">&#x27;content&#x27;</span>,          <span class="hljs-string">&#x27;quotes&#x27;</span>,          <span class="hljs-string">&#x27;counter-reset&#x27;</span>,          <span class="hljs-string">&#x27;counter-increment&#x27;</span>,          <span class="hljs-string">&#x27;resize&#x27;</span>,          <span class="hljs-string">&#x27;user-select&#x27;</span>,          <span class="hljs-string">&#x27;nav-index&#x27;</span>,          <span class="hljs-string">&#x27;nav-up&#x27;</span>,          <span class="hljs-string">&#x27;nav-right&#x27;</span>,          <span class="hljs-string">&#x27;nav-down&#x27;</span>,          <span class="hljs-string">&#x27;nav-left&#x27;</span>,        ],      &#125;,      &#123;        <span class="hljs-comment">// svg样式</span>        properties: [          <span class="hljs-string">&#x27;alignment-baseline&#x27;</span>,          <span class="hljs-string">&#x27;baseline-shift&#x27;</span>,          <span class="hljs-string">&#x27;dominant-baseline&#x27;</span>,          <span class="hljs-string">&#x27;text-anchor&#x27;</span>,          <span class="hljs-string">&#x27;word-spacing&#x27;</span>,          <span class="hljs-string">&#x27;writing-mode&#x27;</span>,          <span class="hljs-string">&#x27;fill&#x27;</span>,          <span class="hljs-string">&#x27;fill-opacity&#x27;</span>,          <span class="hljs-string">&#x27;fill-rule&#x27;</span>,          <span class="hljs-string">&#x27;stroke&#x27;</span>,          <span class="hljs-string">&#x27;stroke-dasharray&#x27;</span>,          <span class="hljs-string">&#x27;stroke-dashoffset&#x27;</span>,          <span class="hljs-string">&#x27;stroke-linecap&#x27;</span>,          <span class="hljs-string">&#x27;stroke-linejoin&#x27;</span>,          <span class="hljs-string">&#x27;stroke-miterlimit&#x27;</span>,          <span class="hljs-string">&#x27;stroke-opacity&#x27;</span>,          <span class="hljs-string">&#x27;stroke-width&#x27;</span>,          <span class="hljs-string">&#x27;color-interpolation&#x27;</span>,          <span class="hljs-string">&#x27;color-interpolation-filters&#x27;</span>,          <span class="hljs-string">&#x27;color-profile&#x27;</span>,          <span class="hljs-string">&#x27;color-rendering&#x27;</span>,          <span class="hljs-string">&#x27;flood-color&#x27;</span>,          <span class="hljs-string">&#x27;flood-opacity&#x27;</span>,          <span class="hljs-string">&#x27;image-rendering&#x27;</span>,          <span class="hljs-string">&#x27;lighting-color&#x27;</span>,          <span class="hljs-string">&#x27;marker-start&#x27;</span>,          <span class="hljs-string">&#x27;marker-mid&#x27;</span>,          <span class="hljs-string">&#x27;marker-end&#x27;</span>,          <span class="hljs-string">&#x27;mask&#x27;</span>,          <span class="hljs-string">&#x27;shape-rendering&#x27;</span>,          <span class="hljs-string">&#x27;stop-color&#x27;</span>,          <span class="hljs-string">&#x27;stop-opacity&#x27;</span>,        ],      &#125;,      &#123;        <span class="hljs-comment">// 动画和过渡</span>        properties: [          <span class="hljs-string">&#x27;transition&#x27;</span>,          <span class="hljs-string">&#x27;transition-delay&#x27;</span>,          <span class="hljs-string">&#x27;transition-timing-function&#x27;</span>,          <span class="hljs-string">&#x27;transition-duration&#x27;</span>,          <span class="hljs-string">&#x27;transition-property&#x27;</span>,          <span class="hljs-string">&#x27;transform&#x27;</span>,          <span class="hljs-string">&#x27;transform-origin&#x27;</span>,          <span class="hljs-string">&#x27;animation&#x27;</span>,          <span class="hljs-string">&#x27;animation-name&#x27;</span>,          <span class="hljs-string">&#x27;animation-duration&#x27;</span>,          <span class="hljs-string">&#x27;animation-play-state&#x27;</span>,          <span class="hljs-string">&#x27;animation-timing-function&#x27;</span>,          <span class="hljs-string">&#x27;animation-delay&#x27;</span>,          <span class="hljs-string">&#x27;animation-iteration-count&#x27;</span>,          <span class="hljs-string">&#x27;animation-direction&#x27;</span>,        ],      &#125;,    ],  &#125;,&#125;;</code></pre></details><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><ol><li>使用两个空格缩进，一行最好不超过 80 个字符。</li><li>使用单引号表示字符串，如果有变量应使用字符串模板而不是连接符。</li><li>普通变量命名应该<code>小写驼峰</code>形式；类、工厂函数都应该用<code>大写驼峰</code>，常量应全大写+下滑线分隔单词。</li><li>枚举类应该以<code>Enum</code>开头<code>大写驼峰</code>，接口应该以<code>I</code>开头<code>大写驼峰</code>。</li><li>优先使用 es6 中语法格式，即对象内可以简写 function，尽量使用 const 然后再是 let 等。</li><li>语句末尾必须带分号。</li><li>条件语句内块级作用域必须带{}。</li><li>对象应静态化，即声明时就声明所有属性，如果需要后期添加属性应使用合并（Object.assign）。</li><li>尽量使用全等（===）。</li><li>对象、数组属性换行后最后一项需要加逗号</li></ol><details>  <summary>tips: 通用js的eslint</summary><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  env: &#123;    browser: <span class="hljs-literal">true</span>,    node: <span class="hljs-literal">true</span>,    es6: <span class="hljs-literal">true</span>,  &#125;,  <span class="hljs-keyword">extends</span>: [<span class="hljs-string">&#x27;eslint:recommended&#x27;</span>],  plugins: [<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;flowtype&#x27;</span>],  parserOptions: &#123;    ecmaVersion: <span class="hljs-number">2018</span>,    sourceType: <span class="hljs-string">&#x27;module&#x27;</span>,    ecmaFeatures: &#123;      jsx: <span class="hljs-literal">true</span>,      legacyDecorators: <span class="hljs-literal">true</span>,    &#125;,  &#125;,  rules: &#123;    <span class="hljs-string">&#x27;no-console&#x27;</span>: process.env.NODE_ENV === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-string">&#x27;error&#x27;</span> : <span class="hljs-string">&#x27;off&#x27;</span>, <span class="hljs-comment">// 禁止console</span>    <span class="hljs-string">&#x27;no-debugger&#x27;</span>: process.env.NODE_ENV === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-string">&#x27;error&#x27;</span> : <span class="hljs-string">&#x27;off&#x27;</span>, <span class="hljs-comment">// 禁止debugger</span>    <span class="hljs-string">&#x27;no-unused-vars&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止定义未使用的变量</span>    <span class="hljs-comment">// &#x27;no-extra-parens&#x27;: [</span>    <span class="hljs-comment">//   &#x27;warn&#x27;,</span>    <span class="hljs-comment">//   &#x27;all&#x27;,</span>    <span class="hljs-comment">//   &#123; enforceForArrowConditionals: false, ignoreJSX: &#x27;multi-line&#x27; &#125;,</span>    <span class="hljs-comment">// ], // 禁止不必要的括号</span>    <span class="hljs-string">&#x27;no-template-curly-in-string&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止在常规字符串中出现模板字面量占位符语法</span>    <span class="hljs-string">&#x27;array-callback-return&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 强制数组方法的回调函数中有 return 语句</span>    <span class="hljs-string">&#x27;block-scoped-var&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 强制把变量的使用限制在其定义的作用域范围内</span>    curly: [<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;all&#x27;</span>], <span class="hljs-comment">// 强制所有控制语句使用一致的括号风格</span>    <span class="hljs-string">&#x27;default-case&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 要求 switch 语句中有 default 分支</span>    <span class="hljs-string">&#x27;dot-location&#x27;</span>: [<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;property&#x27;</span>], <span class="hljs-comment">// 强制在点号之前和之后一致的换行</span>    <span class="hljs-string">&#x27;dot-notation&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 强制尽可能地使用点号</span>    <span class="hljs-string">&#x27;no-caller&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁用 arguments.caller 或 arguments.callee</span>    <span class="hljs-string">&#x27;no-eq-null&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止在没有类型检查操作符的情况下与 null 进行比较</span>    <span class="hljs-string">&#x27;no-empty&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止空块语句</span>    <span class="hljs-string">&#x27;no-eval&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁用 eval()</span>    <span class="hljs-string">&#x27;no-extend-native&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止扩展原生类型</span>    <span class="hljs-string">&#x27;no-extra-bind&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止无意义bind</span>    <span class="hljs-string">&#x27;no-floating-decimal&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止数字字面量中使用前导和末尾小数点</span>    <span class="hljs-string">&#x27;no-implied-eval&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止使用类似 eval() 的方法</span>    <span class="hljs-comment">// &#x27;no-magic-numbers&#x27;: [&#x27;warn&#x27;, &#123; ignoreArrayIndexes: true &#125;], // 禁止魔术数</span>    <span class="hljs-string">&#x27;no-multi-spaces&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止使用多个空格</span>    <span class="hljs-string">&#x27;no-multi-str&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止使用多行字符串</span>    <span class="hljs-string">&#x27;no-self-compare&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止自身比较</span>    <span class="hljs-string">&#x27;no-useless-call&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止不必要的 .call() 和 .apply()</span>    <span class="hljs-string">&#x27;no-unused-expressions&#x27;</span>: [<span class="hljs-string">&#x27;error&#x27;</span>, &#123; <span class="hljs-attr">allowShortCircuit</span>: <span class="hljs-literal">true</span> &#125;], <span class="hljs-comment">// 禁止出现未使用过的表达式</span>    <span class="hljs-string">&#x27;no-unmodified-loop-condition&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁用一成不变的循环条件</span>    <span class="hljs-string">&#x27;no-sequences&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁用逗号操作符</span>    <span class="hljs-string">&#x27;no-useless-return&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止多余的 return 语句</span>    <span class="hljs-string">&#x27;require-await&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止使用不带 await 表达式的 async 函数</span>    <span class="hljs-comment">// &#x27;no-undefined&#x27;: &#x27;error&#x27;, // 禁止将 undefined 作为标识符</span>    <span class="hljs-string">&#x27;no-use-before-define&#x27;</span>: [<span class="hljs-string">&#x27;error&#x27;</span>, &#123; <span class="hljs-attr">classes</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">functions</span>: <span class="hljs-literal">false</span> &#125;], <span class="hljs-comment">// 禁止在变量定义之前使用它们</span>    <span class="hljs-string">&#x27;no-const-assign&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止修改 const 声明的变量</span>    <span class="hljs-string">&#x27;no-dupe-class-members&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止类成员中出现重复的名称</span>    <span class="hljs-string">&#x27;no-duplicate-imports&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止重复导入</span>    <span class="hljs-string">&#x27;no-var&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止使用var</span>    <span class="hljs-string">&#x27;no-useless-escape&#x27;</span>: <span class="hljs-string">&#x27;off&#x27;</span>, <span class="hljs-comment">// 无意义的转意</span>    <span class="hljs-comment">// 样式类</span>    <span class="hljs-string">&#x27;brace-style&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;1tbs&#x27;</span>, &#123; <span class="hljs-attr">allowSingleLine</span>: <span class="hljs-literal">true</span> &#125;], <span class="hljs-comment">// 大括号风格要求</span>    <span class="hljs-string">&#x27;block-spacing&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;always&#x27;</span>], <span class="hljs-comment">// 强制在代码块中开括号前和闭括号后有空格</span>    camelcase: [<span class="hljs-string">&#x27;warn&#x27;</span>, &#123; <span class="hljs-attr">properties</span>: <span class="hljs-string">&#x27;never&#x27;</span>, <span class="hljs-attr">ignoreDestructuring</span>: <span class="hljs-literal">true</span> &#125;], <span class="hljs-comment">//强制使用骆驼拼写法命名约定</span>    <span class="hljs-string">&#x27;comma-dangle&#x27;</span>: [      <span class="hljs-string">&#x27;warn&#x27;</span>,      &#123;        arrays: <span class="hljs-string">&#x27;always-multiline&#x27;</span>,        objects: <span class="hljs-string">&#x27;always-multiline&#x27;</span>,        imports: <span class="hljs-string">&#x27;always-multiline&#x27;</span>,        <span class="hljs-built_in">exports</span>: <span class="hljs-string">&#x27;always-multiline&#x27;</span>,        functions: <span class="hljs-string">&#x27;never&#x27;</span>,      &#125;,    ], <span class="hljs-comment">// 要求使用拖尾逗号</span>    <span class="hljs-string">&#x27;comma-spacing&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, &#123; <span class="hljs-attr">before</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">after</span>: <span class="hljs-literal">true</span> &#125;], <span class="hljs-comment">// 强制在逗号周围使用空格</span>    <span class="hljs-string">&#x27;eol-last&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;always&#x27;</span>], <span class="hljs-comment">// 要求文件末尾保留一行空行</span>    <span class="hljs-string">&#x27;func-call-spacing&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;never&#x27;</span>], <span class="hljs-comment">// 要求在函数标识符和其调用之间有空格</span>    indent: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-number">2</span>, &#123; <span class="hljs-attr">SwitchCase</span>: <span class="hljs-number">1</span> &#125;], <span class="hljs-comment">// 强制使用一致的缩进</span>    <span class="hljs-string">&#x27;jsx-quotes&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;prefer-double&#x27;</span>], <span class="hljs-comment">// 强制在 JSX 属性中使用一致的双引号</span>    <span class="hljs-string">&#x27;new-cap&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, &#123; <span class="hljs-attr">capIsNew</span>: <span class="hljs-literal">false</span> &#125;], <span class="hljs-comment">// 要求构造函数首字母大写</span>    <span class="hljs-string">&#x27;no-multi-assign&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止连续赋值</span>    <span class="hljs-string">&#x27;no-multiple-empty-lines&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, &#123; <span class="hljs-attr">max</span>: <span class="hljs-number">2</span> &#125;], <span class="hljs-comment">// 不允许多个空行</span>    <span class="hljs-string">&#x27;no-unneeded-ternary&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止可以表达为更简单结构的三元操作符</span>    <span class="hljs-string">&#x27;no-whitespace-before-property&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止属性前有空白</span>    <span class="hljs-string">&#x27;quote-props&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;as-needed&#x27;</span>], <span class="hljs-comment">// 要求对象字面量属性名称使用引号</span>    quotes: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;single&#x27;</span>], <span class="hljs-comment">// 强制使用一致的单引号</span>    semi: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;always&#x27;</span>], <span class="hljs-comment">// 使用分号代替 ASI</span>    <span class="hljs-string">&#x27;arrow-body-style&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;as-needed&#x27;</span>], <span class="hljs-comment">// 要求箭头函数体使用大括号</span>    <span class="hljs-string">&#x27;arrow-parens&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;as-needed&#x27;</span>], <span class="hljs-comment">// 要求箭头函数的参数使用圆括号</span>    <span class="hljs-string">&#x27;arrow-spacing&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, &#123; <span class="hljs-attr">before</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">after</span>: <span class="hljs-literal">true</span> &#125;], <span class="hljs-comment">// 要求箭头函数的箭头之前或之后有空格</span>    <span class="hljs-string">&#x27;no-confusing-arrow&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, &#123; <span class="hljs-attr">allowParens</span>: <span class="hljs-literal">true</span> &#125;], <span class="hljs-comment">// 禁止在可能与比较操作符相混淆的地方使用箭头函数</span>    <span class="hljs-string">&#x27;prefer-const&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 求使用 const 声明那些声明后不再被修改的变量</span>    <span class="hljs-string">&#x27;symbol-description&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 要求 symbol 描述</span>    <span class="hljs-string">&#x27;space-before-function-paren&#x27;</span>: [      <span class="hljs-string">&#x27;error&#x27;</span>,      &#123; <span class="hljs-attr">anonymous</span>: <span class="hljs-string">&#x27;ignore&#x27;</span>, <span class="hljs-attr">named</span>: <span class="hljs-string">&#x27;ignore&#x27;</span> &#125;,    ], <span class="hljs-comment">// 要求剪头函数前需要空格</span>    <span class="hljs-string">&#x27;new-parens&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 要求new一定带函数符</span>  &#125;,&#125;;</code></pre></details><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p><a href="https://cn.vuejs.org/v2/style-guide/">vue 风格指南</a></p><ol><li>减少使用 directive 和 mixin。</li><li>v-for 指令下 key 尽量不使用 index。</li><li>vue-html 属性应为小写+横杠连字符，props 声明内为小写驼峰，emit 的事件名也须为小写+横杠。</li><li>vue-html 内不应该出现函数调用。</li><li>声明的函数功能应该有顺序性，即<code>读取接口</code>、<code>数据处理</code>、<code>事件绑定</code>。</li><li>不要在 vue-html 内写过多逻辑或者内联样式。</li></ol><details>  <summary>tips: vue项目的eslint</summary><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  env: &#123;    browser: <span class="hljs-literal">true</span>,    node: <span class="hljs-literal">true</span>,    es6: <span class="hljs-literal">true</span>,  &#125;,  parser: <span class="hljs-string">&#x27;vue-eslint-parser&#x27;</span>,  parserOptions: &#123;    parser: <span class="hljs-string">&#x27;babel-eslint&#x27;</span>,    ecmaVersion: <span class="hljs-number">2018</span>,    sourceType: <span class="hljs-string">&#x27;module&#x27;</span>,    ecmaFeatures: &#123;      jsx: <span class="hljs-literal">true</span>,      legacyDecorators: <span class="hljs-literal">true</span>,    &#125;,  &#125;,  <span class="hljs-keyword">extends</span>: [<span class="hljs-string">&#x27;plugin:vue/essential&#x27;</span>, <span class="hljs-string">&#x27;./eslintrc.default.js&#x27;</span>],  plugins: [<span class="hljs-string">&#x27;vue&#x27;</span>],  rules: &#123;    <span class="hljs-string">&#x27;vue/attribute-hyphenation&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// vue属性使用连字符</span>    <span class="hljs-string">&#x27;vue/html-closing-bracket-newline&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// vue-html标签闭合符换行</span>    <span class="hljs-string">&#x27;vue/html-end-tags&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// vue标签强制闭合</span>    <span class="hljs-string">&#x27;vue/no-multi-spaces&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 不允许多个空格</span>    <span class="hljs-string">&#x27;vue/name-property-casing&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;PascalCase&#x27;</span>], <span class="hljs-comment">// vue组件名称强制驼峰</span>    <span class="hljs-string">&#x27;vue/no-spaces-around-equal-signs-in-attribute&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 属性值前后不能有空格</span>    <span class="hljs-string">&#x27;vue/html-quotes&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;double&#x27;</span>, &#123; <span class="hljs-attr">avoidEscape</span>: <span class="hljs-literal">false</span> &#125;], <span class="hljs-comment">// html属性强制双引号</span>    <span class="hljs-string">&#x27;vue/v-on-style&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;shorthand&#x27;</span>], <span class="hljs-comment">// v-on推荐简写</span>    <span class="hljs-string">&#x27;vue/v-bind-style&#x27;</span>: [<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;shorthand&#x27;</span>], <span class="hljs-comment">// v-bind推荐简写</span>    <span class="hljs-string">&#x27;vue/order-in-components&#x27;</span>: [      <span class="hljs-string">&#x27;warn&#x27;</span>,      &#123;        order: [          <span class="hljs-string">&#x27;el&#x27;</span>,          <span class="hljs-string">&#x27;name&#x27;</span>,          <span class="hljs-string">&#x27;parent&#x27;</span>,          <span class="hljs-string">&#x27;functional&#x27;</span>,          [<span class="hljs-string">&#x27;delimiters&#x27;</span>, <span class="hljs-string">&#x27;comments&#x27;</span>],          [<span class="hljs-string">&#x27;components&#x27;</span>, <span class="hljs-string">&#x27;directives&#x27;</span>, <span class="hljs-string">&#x27;filters&#x27;</span>],          <span class="hljs-string">&#x27;extends&#x27;</span>,          <span class="hljs-string">&#x27;mixins&#x27;</span>,          <span class="hljs-string">&#x27;inheritAttrs&#x27;</span>,          <span class="hljs-string">&#x27;model&#x27;</span>,          [<span class="hljs-string">&#x27;props&#x27;</span>, <span class="hljs-string">&#x27;propsData&#x27;</span>],          <span class="hljs-string">&#x27;data&#x27;</span>,          <span class="hljs-string">&#x27;computed&#x27;</span>,          <span class="hljs-string">&#x27;watch&#x27;</span>,          <span class="hljs-string">&#x27;LIFECYCLE_HOOKS&#x27;</span>,          <span class="hljs-string">&#x27;methods&#x27;</span>,          [<span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;render&#x27;</span>],          <span class="hljs-string">&#x27;renderError&#x27;</span>,        ],      &#125;,    ], <span class="hljs-comment">// vue组件强制属性顺序</span>    <span class="hljs-string">&#x27;vue/no-boolean-default&#x27;</span>: [<span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;default-false&#x27;</span>], <span class="hljs-comment">// 布尔值props必须是否的默认值</span>    <span class="hljs-string">&#x27;vue/padding-line-between-blocks&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// vue文件两个块直接保持空格</span>    <span class="hljs-string">&#x27;vue/no-reserved-component-names&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止使用保留名作为组件名</span>    <span class="hljs-string">&#x27;vue/no-parsing-error&#x27;</span>: [      <span class="hljs-string">&#x27;warn&#x27;</span>,      &#123;        <span class="hljs-string">&#x27;invalid-first-character-of-tag-name&#x27;</span>: <span class="hljs-literal">false</span>,      &#125;,    ], <span class="hljs-comment">// 模板解析错误</span>  &#125;,&#125;;</code></pre></details><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li>类组件方法可以用箭头函数定义，但是在通用组件内应尽量使用 construtor 内 bind 改变 this 指向的写法。</li><li>不允许在 setState 外更改 state，包括其引用。</li><li>应该在 componentDidMount 或 componentDidUpdate 时机读取接口。</li><li>componentDidUpdate 如果涉及视图更新，应注意添加条件判断。</li><li>循环渲染的 dom 需要加 key，尽量不使用 index。</li><li>声明的函数功能应该有顺序性，即<code>读取接口</code>、<code>数据处理</code>、<code>事件绑定</code>。</li></ol><details>  <summary>tips: react项目的eslint</summary><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  root: <span class="hljs-literal">true</span>,  env: &#123;    browser: <span class="hljs-literal">true</span>,    commonjs: <span class="hljs-literal">true</span>,    es6: <span class="hljs-literal">true</span>,    jest: <span class="hljs-literal">true</span>,    node: <span class="hljs-literal">true</span>,  &#125;,  parser: <span class="hljs-string">&#x27;babel-eslint&#x27;</span>,  parserOptions: &#123;    ecmaVersion: <span class="hljs-number">2018</span>,    sourceType: <span class="hljs-string">&#x27;module&#x27;</span>,    ecmaFeatures: &#123;      jsx: <span class="hljs-literal">true</span>,    &#125;,  &#125;,  settings: &#123;    react: &#123;      version: <span class="hljs-string">&#x27;detect&#x27;</span>,    &#125;,  &#125;,  globals: &#123;    __DEV__: <span class="hljs-literal">false</span>,  &#125;,  <span class="hljs-keyword">extends</span>: [<span class="hljs-string">&#x27;./eslintrc.default.js&#x27;</span>],  plugins: [<span class="hljs-string">&#x27;import&#x27;</span>, <span class="hljs-string">&#x27;react&#x27;</span>, <span class="hljs-string">&#x27;jsx-a11y&#x27;</span>],  rules: &#123;    indent: [<span class="hljs-string">&#x27;off&#x27;</span>, <span class="hljs-number">2</span>, &#123; <span class="hljs-attr">SwitchCase</span>: <span class="hljs-number">1</span> &#125;], <span class="hljs-comment">// 强制使用一致的缩进</span>    <span class="hljs-string">&#x27;react/no-access-state-in-setstate&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// setState中不能用state</span>    <span class="hljs-string">&#x27;react/no-adjacent-inline-elements&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 防止相邻的内联元素不被空格分隔</span>    <span class="hljs-string">&#x27;react/no-children-prop&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 不使用children属性</span>    <span class="hljs-string">&#x27;react/no-deprecated&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止使用不推荐的方法</span>    <span class="hljs-string">&#x27;react/no-will-update-set-state&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止在componentWillUpdate中setState</span>    <span class="hljs-string">&#x27;react/no-direct-mutation-state&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止修改state</span>    <span class="hljs-string">&#x27;react/no-is-mounted&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 不允许使用isMount</span>    <span class="hljs-string">&#x27;react/no-multi-comp&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 单文件只能有一个组件</span>    <span class="hljs-string">&#x27;react/no-redundant-should-component-update&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 禁止在PureComponent中使用shouldComponentUpdate</span>    <span class="hljs-string">&#x27;react/no-string-refs&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 不允许使用字符串ref</span>    <span class="hljs-string">&#x27;react/no-this-in-sfc&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 禁止在无状态组件中使用this</span>    <span class="hljs-string">&#x27;react/no-typos&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 防止属性输入打错字</span>    <span class="hljs-string">&#x27;react/no-unescaped-entities&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 防止出现无效字符</span>    <span class="hljs-string">&#x27;react/no-unknown-property&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 防止使用未知的DOM属性</span>    <span class="hljs-string">&#x27;react/prefer-es6-class&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 使用es6类定义组件</span>    <span class="hljs-string">&#x27;react/require-render-return&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// render需要返回</span>    <span class="hljs-string">&#x27;react/sort-comp&#x27;</span>: [      <span class="hljs-string">&#x27;warn&#x27;</span>,      &#123;        order: [<span class="hljs-string">&#x27;static-methods&#x27;</span>, <span class="hljs-string">&#x27;lifecycle&#x27;</span>, <span class="hljs-string">&#x27;everything-else&#x27;</span>, <span class="hljs-string">&#x27;render&#x27;</span>],        groups: &#123;          lifecycle: [            <span class="hljs-string">&#x27;displayName&#x27;</span>,            <span class="hljs-string">&#x27;propTypes&#x27;</span>,            <span class="hljs-string">&#x27;contextTypes&#x27;</span>,            <span class="hljs-string">&#x27;childContextTypes&#x27;</span>,            <span class="hljs-string">&#x27;mixins&#x27;</span>,            <span class="hljs-string">&#x27;statics&#x27;</span>,            <span class="hljs-string">&#x27;defaultProps&#x27;</span>,            <span class="hljs-string">&#x27;state&#x27;</span>,            <span class="hljs-string">&#x27;constructor&#x27;</span>,            <span class="hljs-string">&#x27;getDefaultProps&#x27;</span>,            <span class="hljs-string">&#x27;getInitialState&#x27;</span>,            <span class="hljs-string">&#x27;getChildContext&#x27;</span>,            <span class="hljs-string">&#x27;getDerivedStateFromProps&#x27;</span>,            <span class="hljs-string">&#x27;componentWillMount&#x27;</span>,            <span class="hljs-string">&#x27;UNSAFE_componentWillMount&#x27;</span>,            <span class="hljs-string">&#x27;componentDidMount&#x27;</span>,            <span class="hljs-string">&#x27;componentWillReceiveProps&#x27;</span>,            <span class="hljs-string">&#x27;UNSAFE_componentWillReceiveProps&#x27;</span>,            <span class="hljs-string">&#x27;shouldComponentUpdate&#x27;</span>,            <span class="hljs-string">&#x27;componentWillUpdate&#x27;</span>,            <span class="hljs-string">&#x27;UNSAFE_componentWillUpdate&#x27;</span>,            <span class="hljs-string">&#x27;getSnapshotBeforeUpdate&#x27;</span>,            <span class="hljs-string">&#x27;componentDidUpdate&#x27;</span>,            <span class="hljs-string">&#x27;componentDidCatch&#x27;</span>,            <span class="hljs-string">&#x27;componentWillUnmount&#x27;</span>,          ],        &#125;,      &#125;,    ], <span class="hljs-comment">// 规定组件属性顺序</span>    <span class="hljs-string">&#x27;react/style-prop-object&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 要求样式为对象</span>    <span class="hljs-string">&#x27;react/void-dom-elements-no-children&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 防止空元素传children</span>    <span class="hljs-string">&#x27;react/jsx-boolean-value&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 布尔值尽可能不传true</span>    <span class="hljs-string">&#x27;react/jsx-key&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 循环dom需要设置key</span>    <span class="hljs-comment">// &#x27;react/jsx-no-bind&#x27;: [</span>    <span class="hljs-comment">//   &#x27;warn&#x27;,</span>    <span class="hljs-comment">//   &#123; ignoreDOMComponents: true, ignoreRefs: true &#125;,</span>    <span class="hljs-comment">// ], // 阻止jsx中编写函数</span>    <span class="hljs-string">&#x27;react/jsx-no-duplicate-props&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// jsx不允许相同属性</span>    <span class="hljs-string">&#x27;react/jsx-no-script-url&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// jsx不允许a扁鹊的javascript：</span>    <span class="hljs-string">&#x27;react/jsx-no-undef&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// 不允许未定义就使用的组件</span>    <span class="hljs-string">&#x27;react/jsx-no-useless-fragment&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 阻止无意义的fragment</span>    <span class="hljs-string">&#x27;react/jsx-pascal-case&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 组件必须驼峰</span>    <span class="hljs-string">&#x27;react/jsx-props-no-multi-spaces&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// 属性名间不允许过多空格</span>    <span class="hljs-string">&#x27;react/jsx-uses-react&#x27;</span>: <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-comment">// jsx需要React变量</span>    <span class="hljs-string">&#x27;react/jsx-uses-vars&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">// jsx引用变量前定义</span>  &#125;,&#125;;</code></pre></details>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Vue</tag>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
      <tag>html</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
