# 变量提升和函数声明提升

关于 Javascript 中的变量提升（variable hoisting）可能在前端界已经耳熟能详了，可能你会觉得设计初衷是什么呢，或者这里有出于什么考虑以及解决了什么问题呢？因为这块“特性”成为了前端人必须了解并绕过的坑，也可能成为了不少前端人的困扰。

其实根据 Brendan Eich 的说法：
![Brendan Eich本人回复关于变量提升](https://raw.githubusercontent.com/ben-lau/blog/master/assets/images/brendan-erich-answer.png)

大概意思就是，变量提升是函数提升的意外结果。（手动狗头）

## 题目

下面开始先给几道有趣的题：

1.  ```javascript
    if (!(Ben in window)) {
      console.log(1);
      var Ben = 'handsome';
    }
    console.log(Ben in window);
    console.log(Ben);
    ```

2.  ```javascript
    var a;
    (function () {
      a = 1;
      console.log(a);
      if (false) {
        var a = 2;
        console.log(a);
      }
      console.log(a);
    })();
    console.log(a);
    ```

3.  ```javascript
    var a = 1;
    {
      console.log(a);
      var a = 2;
      console.log(a);
    }
    ```

4.  ```javascript
    var b = 1;
    (function () {
      console.log(b);
      var b = 2;
      console.log(b);
    })();
    ```

5.  ```javascript
    var c = 1;

    function func1() {
      console.log(c);
    }

    function func2() {
      var c = 2;
      func1();
    }

    func2();
    ```

6.  ```javascript
    {
      function a() {}
      a = 1;
    }
    console.log(a);
    ```

7.  ```javascript
    {
      function a() {}
      a = 1;
      function a() {}
    }
    console.log(a);
    ```

8.  ```javascript
    {
      function a() {}
      a = 1;
      function a() {}
      a = 2;
    }
    console.log(a);
    ```

<details>
  <summary>题目1解析</summary>
因为 var 声明会在preparse时期执行，先于执行语句解析声明变量，且 var 声明作用于函数执行的作用域，所以会穿透 for 和 if 语句。
</details>

<details>
  <summary>题目2解析</summary>
因为 var 声明会在 preparse 时期执行，先于执行语句解析声明变量，且 var 声明作用于函数执行的作用域，所以会穿透 for 和 if 语句。而 function 是有函数作用域的，所以 iife 内的 a 变量为私有，所以内部都会打印 1，函数外的 a 因未被赋值所以 undefined。
</details>

<details>
  <summary>题目3解析</summary>
因为 {} 并不产生作用域，var又不创造暂时性死区。
</details>

<details>
  <summary>题目4解析</summary>
这里就是因为函数作用域的问题，但是为什么第一个打印还是undefined，因为javascript寻找变量顺序是当前作用域一直向上寻找，而这里因为变量提升所以在iife函数中声明了私有变量，但是未赋值，所以为undefined。
</details>

<details>
  <summary>题目5解析</summary>
这里是因为Javascript采用的是词法作用域，函数作用域其实在定义时就已经决定了，所以func1获取不到func2中的私有变量。
</details>
